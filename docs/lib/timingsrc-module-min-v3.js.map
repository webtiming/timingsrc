{"version":3,"file":"timingsrc-module-min-v3.js","sources":["../../v3/util/utils.js","../../v3/util/endpoint.js","../../v3/util/interval.js","../../v3/util/motionutils.js","../../v3/util/binarysearch.js","../../v3/util/eventify.js","../../v3/util/observablemap.js","../../v3/util/timeout.js","../../v3/timingobject/masterclock.js","../../v3/timingobject/internalprovider.js","../../v3/timingobject/externalprovider.js","../../v3/timingobject/timingobject.js","../../v3/timingobject/skewconverter.js","../../v3/timingobject/delayconverter.js","../../v3/timingobject/scaleconverter.js","../../v3/timingobject/loopconverter.js","../../v3/timingobject/rangeconverter.js","../../v3/timingobject/timeshiftconverter.js","../../v3/timingobject/timingsampler.js","../../v3/timingobject/positioncallback.js","../../v3/dataset/cuecollection.js","../../v3/dataset/dataset.js","../../v3/dataset/subset.js","../../v3/sequencing/schedule.js","../../v3/sequencing/basesequencer.js","../../v3/sequencing/pointsequencer.js","../../v3/sequencing/intervalsequencer.js","../../v3/ui/datasetviewer.js","../../v3/ui/timingprogress.js","../../v3/index.js"],"sourcesContent":["/*\n    Copyright 2020\n    Author : Ingar Arntzen\n\n    This file is part of the Timingsrc module.\n\n    Timingsrc is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    Timingsrc is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\nexport function random_string(length) {\n    var text = \"\";\n    var possible = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n    for(var i = 0; i < length; i++) {\n        text += possible.charAt(Math.floor(Math.random() * possible.length));\n    }\n    return text;\n}\n\n\n/* Set Comparison */\nexport function eqSet(as, bs) {\n    return as.size === bs.size && all(isIn(bs), as);\n}\n\nexport function all(pred, as) {\n    for (var a of as) if (!pred(a)) return false;\n    return true;\n}\n\nexport function isIn(as) {\n    return function (a) {\n        return as.has(a);\n    };\n}\n\n\n/*\n    get the difference of two Maps\n    key in a but not in b\n*/\nexport const map_difference = function (a, b) {\n    if (a.size == 0) {\n        return new Map();\n    } else if (b.size == 0) {\n        return a;\n    } else {\n        return new Map([...a].filter(function ([key, value]) {\n            return !b.has(key)\n        }));\n    }\n};\n\n/*\n    get the intersection of two Maps\n    key in a and b\n*/\nexport const map_intersect = function (a, b) {\n    [a, b] = (a.size <= b.size) ? [a,b] : [b,a];\n    if (a.size == 0) {\n        // No intersect\n        return new Map();\n    }\n    return new Map([...a].filter(function ([key, value]) {\n        return b.has(key)\n    }));\n};\n\n/*\n\nNOTE : just as good to do \n    let merged = new Map(...map0, ...map1, ...)\n\neffective concatenation of multiple arrays\n- order - if true preserves ordering of input arrays\n        - else sorts input arrays (longest first)\n        - default false is more effective\n- copy  - if true leaves input arrays unchanged, copy\n          values into new array\n        - if false copies remainder arrays into the first\n          array\n        - default false is more effective\n*/\nexport function map_merge(array_of_maps, options={}) {\n    let {copy=false, order=false} = options;\n    // check input\n    if (array_of_maps instanceof Map) {\n        return array_of_maps;\n    }\n    if (!Array.isArray(array_of_maps)) {\n        throw new Error(\"illegal input array_of_maps\", array_of_maps);\n    }\n    if (array_of_maps.length == 0) {\n        throw new Error(\"empty array_of_maps\");\n    }\n    let is_maps = array_of_maps.map((o) => {\n        return (o instanceof Map);\n    });\n    if (!is_maps.every((e) => e == true)) {\n        throw new Error(\"some object in array_of_maps is not a Map\", array_of_maps);\n    }\n    // order\n    if (!order) {\n        // sort array_of_maps according to size - longest first\n        array_of_maps.sort((a, b) => b.size - a.size);\n    }\n    // copy\n    let first = (copy) ? new Map() : array_of_maps.shift(); \n    // fill up first Map with entries from other Maps\n    for (let m of array_of_maps) {\n        for (let [key, val] of m.entries()) {\n            first.set(key, val);\n        }\n    }\n    return first;\n}\n\n\nexport function divmod (n, d) {\n    let r = n % d;\n    let q = (n-r)/d;\n    return [q, r];\n}\n\n\nexport function isIterable(obj) {\n    // checks for null and undefined\n    if (obj == null) {\n        return false;\n    }\n    return typeof obj[Symbol.iterator] === 'function';\n}\n\n/*\n    effective concatenation of multiple arrays\n    - order - if true preserves ordering of input arrays\n            - else sorts input arrays (longest first)\n            - default false is more effective\n    - copy  - if true leaves input arrays unchanged, copy\n              values into new array\n            - if false copies remainder arrays into the first\n              array\n            - default false is more effective\n*/\nexport function array_concat(arrays, options = {}) {\n    let {copy=false, order=false} = options;\n    if (arrays.length == 0) {\n        return [];\n    }\n    if (arrays.length == 1) {\n        return arrays[0];\n    }\n    let total_len = arrays.reduce((acc, cur) => acc + cur.length, 0);\n    // order\n    if (!order) {\n        // sort arrays according to length - longest first\n        arrays.sort((a, b) => b.length - a.length);\n    }\n    // copy\n    let first = (copy) ? [] : arrays.shift();\n    let start = first.length;\n    // reserve memory total length\n    first.length = total_len;\n    // fill up first with entries from other arrays\n    let end, len;\n    for (let arr of arrays) {\n        len = arr.length;\n        end = start + len;\n        for (let i=0; i<len; i++) {\n            first[start + i] = arr[i]\n        }\n        start = end;\n    }\n    return first;\n};\n\n\n\n/*\n    default object equals\n*/\nexport function object_equals(a, b) {\n    // Create arrays of property names\n    let aProps = Object.getOwnPropertyNames(a);\n    let bProps = Object.getOwnPropertyNames(b);\n    let len = aProps.length;\n    let propName;\n    // If properties lenght is different => not equal\n    if (aProps.length != bProps.length) {\n        return false;\n    }\n    for (let i=0; i<len; i++) {\n        propName = aProps[i];\n        // If property values are not equal => not equal\n        if (a[propName] !== b[propName]) {\n            return false;\n        }\n    }\n    // equal\n    return true;\n}\n\n\n/* document readypromise */\nexport const docready = new Promise(function(resolve) {\n    if (document.readyState === 'complete') {\n        resolve();\n    } else {\n        let onReady = function () {\n            resolve();\n            document.removeEventListener('DOMContentLoaded', onReady, true);\n            window.removeEventListener('load', onReady, true);\n        };\n        document.addEventListener('DOMContentLoaded', onReady, true);\n        window.addEventListener('load', onReady, true);\n    }\n});\n\n","/*\n\tCopyright 2020\n\tAuthor : Ingar Arntzen\n\n\tThis file is part of the Timingsrc module.\n\n\tTimingsrc is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU Lesser General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tTimingsrc is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU Lesser General Public License for more details.\n\n\tYou should have received a copy of the GNU Lesser General Public License\n\talong with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\nconst isNumber = function(n) {\n\tlet N = parseFloat(n);\n    return (n===N && !isNaN(N));\n};\n\n\n/*********************************************************\n\nENDPOINT\n\nUtilities for interval endpoints comparison\n\n**********************************************************/\n\n/*\n\tendpoint modes - in endpoint order\n\tendpoint order\n\tp), [p, [p], p], (p\n*/\nconst MODE_RIGHT_OPEN = 0;\nconst MODE_LEFT_CLOSED = 1;\nconst MODE_SINGULAR = 2;\nconst MODE_RIGHT_CLOSED = 3;\nconst MODE_LEFT_OPEN = 4;\n\n// create endpoint\nfunction create(val, right, closed, singular) {\n\t// make sure infinity endpoints are legal\n\tif (val == Infinity) {\n\t\tif (right == false || closed == false) {\n\t\t\tthrow new Error(\"Infinity endpoint must be right-closed or singular\");\n\t\t}\n\t}\n\tif (val == -Infinity) {\n\t\tif (right == true || closed == false) {\n\t\t\tthrow new Error(\"-Infinity endpoint must be left-closed or singular\")\n\t\t}\n\t}\n\treturn [val, right, closed, singular];\n}\n\n\n/*\n\tresolve endpoint mode\n*/\nfunction get_mode(e) {\n\t// if right, closed is given\n\t// use that instead of singular\n\tlet [val, right, closed, singular] = e;\n\tif (right == undefined) {\n\t\treturn MODE_SINGULAR;\n\t} else if (right) {\n\t\tif (closed) {\n\t\t\treturn MODE_RIGHT_CLOSED;\n\t\t} else {\n\t\t\treturn MODE_RIGHT_OPEN;\n\t\t}\n\t} else {\n\t\tif (closed) {\n\t\t\treturn MODE_LEFT_CLOSED;\n\t\t} else {\n\t\t\treturn MODE_LEFT_OPEN;\n\t\t}\n\t}\n}\n\n/*\n\tget order\n\n\tgiven two endpoints\n\treturn two numbers representing their order\n\n\talso accepts regular numbers as endpoints\n\tregular number are represented as singular endpoints\n\n\tfor endpoint values that are not\n\tequal, these values convey order directly,\n\totherwise endpoint mode numbers 0-4 are returned\n\n\tparameters are either\n\t- point: Number\n\tor,\n\t- endpoint: [\n\t\tvalue (number),\n\t\tright (bool),\n\t\tclosed (bool),\n\t\tsingular (bool)\n\t  ]\n*/\n\nfunction get_order(e1, e2) {\n\t// support plain numbers (not endpoints)\n\tif (e1.length === undefined) {\n\t\tif (!isNumber(e1)) {\n\t\t\tthrow new Error(\"e1 not a number\", e1);\n\t\t}\n\t\te1 = create(e1, undefined, undefined, true);\n\t}\n\tif (e2.length === undefined) {\n\t\tif (!isNumber(e2)) {\n\t\t\tthrow new Error(\"e2 not a number\", e2);\n\t\t}\n\t\te2 = create(e2, undefined, undefined, true);\n\t}\n\tif (e1[0] != e2[0]) {\n\t\t// different values\n\t\treturn [e1[0], e2[0]];\n\t} else {\n\t\t// equal values\n\t\treturn [get_mode(e1), get_mode(e2)];\n\t}\n}\n\n/*\n\treturn true if e1 is ordered before e2\n\tfalse if equal\n*/\n\nfunction leftof(e1, e2) {\n\tlet [order1, order2] = get_order(e1, e2);\n\treturn (order1 < order2);\n}\n\n/*\n\treturn true if e1 is ordered after e2\n\tfalse is equal\n*/\n\nfunction rightof(e1, e2) {\n\tlet [order1, order2] = get_order(e1, e2);\n\treturn (order1 > order2);\n}\n\n/*\n\treturn true if e1 is ordered equal to e2\n*/\n\nfunction equals(e1, e2) {\n\tlet [order1, order2] = get_order(e1, e2);\n\treturn (order1 == order2);\n}\n\n/*\n\treturn -1 if ordering e1, e2 is correct\n\treturn 0 if e1 and e2 is equal\n\treturn 1 if ordering e1, e2 is incorrect\n*/\n\nfunction cmp(e1, e2) {\n\tlet [order1, order2] = get_order(e1, e2);\n\tlet diff = order1 - order2;\n\tif (diff == 0) return 0;\n\treturn (diff > 0) ? 1 : -1;\n}\n\n\nfunction min(e1, e2) {\n    return (cmp(e1, e2) <= 0) ? e1 : e2;\n}\n\n\nfunction max(e1, e2) {\n    return (cmp(e1, e2) <= 0) ? e2 : e1;\n}\n\n\n/*\n\thuman friendly endpoint representation\n*/\nfunction toString(e) {\n\tif (e.length === undefined) {\n\t\treturn e.toString();\n\t} else {\n\t\tlet mode = get_mode(e);\n\t\tlet val = e[0];\n\t\tif (val == Infinity || val == -Infinity) {\n\t\t\tval = \"--\";\n\t\t}\n\t\tif (mode == MODE_RIGHT_OPEN) {\n\t\t\treturn `${val})`\n\t\t} else if (mode == MODE_LEFT_CLOSED) {\n\t\t\treturn `[${val}`\n\t\t} else if (mode == MODE_SINGULAR){\n\t\t\treturn `[${val}]`\n\t\t} else if (mode == MODE_RIGHT_CLOSED) {\n\t\t\treturn `${val}]`\n\t\t} else if (mode == MODE_LEFT_OPEN) {\n\t\t\treturn `(${val}`\n\t\t}\n\t}\n}\n\n\nexport default {\n\tcmp,\n\ttoString,\n\tequals,\n\trightof,\n\tleftof,\n\tcreate,\n\tmin,\n\tmax\n};\n","/*\n\tCopyright 2020\n\tAuthor : Ingar Arntzen\n\n\tThis file is part of the Timingsrc module.\n\n\tTimingsrc is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU Lesser General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tTimingsrc is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU Lesser General Public License for more details.\n\n\tYou should have received a copy of the GNU Lesser General Public License\n\talong with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\nimport endpoint from './endpoint.js';\n\n\nconst isNumber = function(n) {\n\tlet N = parseFloat(n);\n    return (n===N && !isNaN(N));\n};\n\n/*********************************************************\nINTERVAL ERROR\n**********************************************************/\n\nclass IntervalError extends Error {\n\tconstructor(message) {\n\t\tsuper(message);\n\t\tthis.name == \"IntervalError\";\n\t}\n};\n\n\n/*********************************************************\nINTERVAL\n**********************************************************/\n\n// Interval Relations\nconst Relation = Object.freeze({\n\tOUTSIDE_LEFT: 64,  \t// 0b1000000\n\tOVERLAP_LEFT: 32,  \t// 0b0100000\n\tCOVERED: 16,\t\t// 0b0010000\n\tEQUALS: 8,\t\t\t// 0b0001000\n\tCOVERS: 4,\t\t\t// 0b0000100\n\tOVERLAP_RIGHT: 2,\t// 0b0000010\n\tOUTSIDE_RIGHT: 1\t// 0b0000001\n});\n\n/*\n    Masks for Interval matching\n*/\nconst MATCH_OUTSIDE = Relation.OUTSIDE_LEFT + Relation.OUTSIDE_RIGHT;\nconst MATCH_INSIDE = Relation.EQUALS + Relation.COVERED;\nconst MATCH_OVERLAP = MATCH_INSIDE +\n\tRelation.OVERLAP_LEFT + Relation.OVERLAP_RIGHT;\nconst MATCH_COVERS = MATCH_OVERLAP + Relation.COVERS;\nconst MATCH_ALL = MATCH_COVERS + MATCH_OUTSIDE;\n\nconst Match = Object.freeze({\n\tOUTSIDE: MATCH_OUTSIDE,\n\tINSIDE: MATCH_INSIDE,\n\tOVERLAP: MATCH_OVERLAP,\n\tCOVERS: MATCH_COVERS,\n\tALL: MATCH_ALL\n});\n\n\n/*********************************************************\nCOMPARE INTERVALS\n**********************************************************\n\ncompare (a, b)\nparam a Interval\nparam b Interval\nreturns IntervalRelation\n\ncompares interval b to interval a\ne.g. return value COVERED reads b is covered by a.\n\ncmp_1 = endpoint_compare(b_low, a_low);\ncmp_2 = endpoint_compare(b_high, a_high);\n\nkey = 10*cmp_1 + cmp_2\n\ncmp_1  cmp_2  key  relation\n=====  =====  ===  ============================\n-1     -1     -11  OUTSIDE_LEFT, PARTIAL_LEFT\n-1 \t   0      -10  COVERS\n-1     1       -9  COVERS\n0\t   -1      -1  COVERED\n0      0        0  EQUAL\n0 \t   1        1  COVERS\n1      -1       9  COVERED\n1 \t   0       10  COVERED\n1 \t   1       11  OUTSIDE_RIGHT, OVERLAP_RIGHT\n=====  =====  ===  ============================\n\n**********************************************************/\n\nfunction compare(a, b) {\n\tif (! a instanceof Interval) {\n\t\t// could be a number\n\t\tif (isNumber(a)) {\n\t\t\ta = new Interval(a);\n\t\t} else {\n\t\t\tthrow new IntervalError(\"a not interval\", a);\n\t\t}\n\t}\n\tif (! b instanceof Interval) {\n\t\t// could be a number\n\t\tif (isNumber(b)) {\n\t\t\tb = new Interval(b);\n\t\t} else {\n\t\t\tthrow new IntervalError(\"b not interval\", b);\n\t\t}\n\t}\n\n\tlet cmp_1 = endpoint.cmp(a.endpointLow, b.endpointLow);\n\tlet cmp_2 = endpoint.cmp(a.endpointHigh, b.endpointHigh);\n\tlet key = cmp_1*10 + cmp_2;\n\n\tif (key == 11) {\n\t\t// OUTSIDE_LEFT or PARTIAL_LEFT\n\t\tif (endpoint.leftof(b.endpointHigh, a.endpointLow)) {\n\t\t\treturn Relation.OUTSIDE_RIGHT;\n\t\t} else {\n\t\t\treturn Relation.OVERLAP_RIGHT;\n\t\t}\n\t} else if ([-1, 9, 10].includes(key)) {\n\t\treturn Relation.COVERED;\n\t} else if ([1, -9, -10].includes(key)) {\n\t\treturn Relation.COVERS;\n\t} else if (key == 0) {\n\t\treturn Relation.EQUALS;\n\t} else {\n\t\t// key == -11\n\t\t// OUTSIDE_RIGHT, PARTIAL_RIGHT\n\t\tif (endpoint.rightof(b.endpointLow, a.endpointHigh)) {\n\t\t\treturn Relation.OUTSIDE_LEFT;\n\t\t} else {\n\t\t\treturn Relation.OVERLAP_LEFT;\n\t\t}\n\t}\n}\n\n/*********************************************************\nCOMPARE INTERVALS BY ENDPOINT\n**********************************************************\n\ncmp functions for sorting intervals (ascending) based on\nendpoint low or high\n\nuse with array.sort()\n\n**********************************************************/\n\nfunction _make_interval_cmp(low) {\n\treturn function cmp (a, b) {\n\t\tlet e1, e2;\n\t\tif (low) {\n\t\t\te1 = [a.low, false, a.lowInclude, a.singular];\n\t\t\te2 = [b.low, false, b.lowInclude, a.singular];\n\t\t} else {\n\t\t\te1 = [a.high, true, a.highInclude, a.singular];\n\t\t\te2 = [b.high, true, b.highInclude, a.singular];\n\t\t}\n\t\treturn endpoint.cmp(e1, e2);\n\t}\n}\n\n\n\n/**\n *  Create interval from two endpoints\n */\n\nfunction fromEndpoints(endpointLow, endpointHigh) {\n\tlet [low, low_right, low_closed, low_singular] = endpointLow;\n\tlet [high, high_right, high_closed, high_singular] = endpointHigh;\n\tif (low_right) {\n\t\tthrow new IntervalError(\"illegal endpointLow - bracket must be left\");\n\t}\n\tif (!high_right) {\n\t\tthrow new IntervalError(\"illegal endpointHigh - bracket must be right\");\n\t}\n\treturn new Interval(low, high, low_closed, high_closed);\n};\n\n\n// intersect two intervals\nfunction intersect(a, b) {\n\tlet rel = compare(a, b);\n\tif (rel == Relation.OUTSIDE_LEFT) {\n\t\treturn [];\n\t} else if (rel == Relation.OVERLAP_LEFT) {\n\t\treturn [Interval.fromEndpoints(b.endpointLow, a.endpointHigh)];\n\t} else if (rel == Relation.COVERS) {\n\t\treturn [b];\n\t} else if (rel == Relation.EQUALS) {\n\t\treturn [a]; // or b\n\t} else if (rel == Relation.COVERED) {\n\t\treturn [a];\n\t} else if (rel == Relation.OVERLAP_RIGHT) {\n\t\treturn [Interval.fromEndpoints(a.endpointLow, b.endpointHigh)];\n\t} else if (rel == Relation.OUTSIDE_RIGHT) {\n\t\treturn [];\n\t}\n}\n\n// union of two intervals\nfunction union(a, b) {\n\tlet rel = compare(a, b);\n\tif (rel == Relation.OUTSIDE_LEFT) {\n\t\t// merge\n\t\t// [aLow,aHigh)[bLow, bHigh] or [aLow,aHigh](bLow, bHigh]\n\t\tif (a.high == b.low) {\n\t\t\treturn [Interval.fromEndpoints(a.endpointLow, b.endpointHigh)]; \n\t\t} else {\n\t\t\treturn [a, b];\n\t\t}\n\t} else if (rel == Relation.OVERLAP_LEFT) {\n\t\treturn [Interval.fromEndpoints(a.endpointLow, b.endpointHigh)];\n\t} else if (rel == Relation.COVERS) {\n\t\treturn [a];\n\t} else if (rel == Relation.EQUALS) {\n\t\treturn [a]; // or b\n\t} else if (rel == Relation.COVERED) {\n\t\treturn [b];\n\t} else if (rel == Relation.OVERLAP_RIGHT) {\n\t\treturn [Interval.fromEndpoints(b.endpointLow, a.endpointHigh)];\n\t} else if (rel == Relation.OUTSIDE_RIGHT) {\n\t\t// merge\n\t\t// [bLow,bHigh)[aLow, aHigh] or [bLow,bHigh](aLow, aHigh]\n\t\tif (a.high == b.low) {\n\t\t\treturn [Interval.fromEndpoints(b.endpointLow, a.endpointHigh)]; \n\t\t} else {\n\t\t\treturn [b, a];\n\t\t}\n\t}\n}\n\n// intersection of multiple intervals\nfunction intersectAll(intervals) {\n\tintervals.sort(Interval.cmpLow);\n\tif (intervals.length <= 1) {\n\t\treturn intervals;\n\t}\n\tconst result = [intervals.shift()];\n\twhile (intervals.length > 0) {\n\t\tlet prev = result.pop();\n\t\tlet next = intervals.shift()\n\t\tresult.push(...Interval.intersect(prev, next));\n\t}\n\treturn result;\n}\n\n// union of multiple interval\nfunction unionAll(intervals) {\n\tintervals.sort(Interval.cmpLow);\n\tif (intervals.length <= 1) {\n\t\treturn intervals;\n\t}\n\tconst result = [intervals.shift()];\n\twhile (intervals.length > 0) {\n\t\tlet prev = result.pop();\n\t\tlet next = intervals.shift()\n\t\tresult.push(...Interval.union(prev, next));\n\t}\n\treturn result;\n}\n\n\n/*********************************************************\nINTERVAL CLASS\n**********************************************************/\n\nclass Interval {\n\n\t/*\n\t\tAdd static variables to Interval class.\n\t*/\n\tstatic Relation = Relation;\n\tstatic Match = Match;\n\tstatic cmpLow = _make_interval_cmp(true);\n\tstatic cmpHigh = _make_interval_cmp(false);\n\tstatic fromEndpoints = fromEndpoints;\n\tstatic intersect = intersect;\n\tstatic union = union;\n\tstatic intersectAll = intersectAll;\n\tstatic unionAll = unionAll;\n\n\t/*\n\t\tConstructor\n\t*/\n\tconstructor (low, high, lowInclude, highInclude) {\n\t\tvar lowIsNumber = isNumber(low);\n\t\tvar highIsNumber = isNumber(high);\n\t\t// new Interval(3.0) defines singular - low === high\n\t\tif (lowIsNumber && high === undefined) high = low;\n\t\tif (!isNumber(low)) throw new IntervalError(\"low not a number\");\n\t\tif (!isNumber(high)) throw new IntervalError(\"high not a number\");\n\t\tif (low > high) throw new IntervalError(\"low > high\");\n\t\tif (low === high) {\n\t\t\tlowInclude = true;\n\t\t\thighInclude = true;\n\t\t}\n\t\tif (low === -Infinity) lowInclude = true;\n\t\tif (high === Infinity) highInclude = true;\n\t\tif (lowInclude === undefined) lowInclude = true;\n\t\tif (highInclude === undefined) highInclude = false;\n\t\tif (typeof lowInclude !== \"boolean\") throw new IntervalError(\"lowInclude not boolean\");\n\t\tif (typeof highInclude !== \"boolean\") throw new IntervalError(\"highInclude not boolean\");\n\t\tthis.low = low;\n\t\tthis.high = high;\n\t\tthis.lowInclude = lowInclude;\n\t\tthis.highInclude = highInclude;\n\t\tthis.length = this.high - this.low;\n\t\tthis.singular = (this.low === this.high);\n\t\tthis.finite = (isFinite(this.low) && isFinite(this.high));\n\n\t\t/*\n\t\t\tAccessors for full endpoint representationo\n\t\t\t[value (number), right (bool), closed (bool)]\n\n\t\t\t- use with inside(endpoint, interval)\n\t\t*/\n\t\tthis.endpointLow = endpoint.create(this.low, false, this.lowInclude, this.singular);\n\t\tthis.endpointHigh = endpoint.create(this.high, true, this.highInclude, this.singular);\n\t}\n\n\n\t/**\n\t *  Instance methods\n\t */\n\n\ttoString () {\n\t\tconst toString = endpoint.toString;\n\t\tif (this.singular) {\n\t\t\tlet p = this.endpointLow[0];\n\t\t\treturn `[${p}]`;\n\t\t} else {\n\t\t\tlet low = endpoint.toString(this.endpointLow);\n\t\t\tlet high = endpoint.toString(this.endpointHigh);\n\t\t\treturn `${low},${high}`;\n\t\t}\n\t};\n\n\tcovers_endpoint (p) {\n\t\tlet leftof = endpoint.leftof(p, this.endpointLow);\n\t\tlet rightof = endpoint.rightof(p, this.endpointHigh);\n\t\treturn !leftof && !rightof;\n\t}\n\n\tcompare (other) {\n\t\treturn compare(this, other);\n\t}\n\n\tequals (other) {\n\t\treturn compare(this, other) == Relation.EQUALS;\n\t}\n\n\t/*\n\t\tdefault mode - all except outside\n\t\t2+4+8+16+32 = 62\n\t*/\n\tmatch (other, mask=MATCH_COVERS) {\n\t\tlet relation = compare(this, other);\n\t\treturn Boolean(mask & relation);\n\t}\n}\n\nexport default Interval;\n\n","/*\n\tCopyright 2020\n\tAuthor : Ingar Arntzen\n\n    This file is part of the Timingsrc module.\n\n    Timingsrc is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    Timingsrc is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport endpoint from './endpoint.js';\nimport Interval from './interval.js';\n\n\n// sort func\nconst cmp = function (a, b) {return a - b;};\n\n/*******************************************************************\n BASIC\n*******************************************************************/\n\nexport function equalVectors(vector_a, vector_b) {\n    let pos = vector_a.position == vector_b.position;\n    let vel = vector_a.velocity == vector_b.velocity;\n    let acc = vector_a.acceleration == vector_b.acceleration;\n    let ts = vector_a.timestamp == vector_b.timestamp;\n    return pos && vel && acc && ts;\n};\n\n\nexport function copyVector(vector) {\n    return {\n        position: vector.position,\n        velocity: vector.velocity,\n        acceleration: vector.acceleration,\n        timestamp: vector.timestamp\n    }\n};\n\n/*\n    Calculate vector snapshot for motion defined by vector at time ts\n\n    vector: [p0,v0,a0,t0]\n    t0 and ts are absolute time from same clock, in seconds\n*/\n\nexport function calculateVector(vector, ts) {\n\tif (ts === undefined) {\n\t    throw new Error (\"no ts provided for calculateVector\");\n\t}\n\tconst deltaSec = ts - vector.timestamp;\n\treturn {\n\t\tposition : vector.position + vector.velocity*deltaSec + 0.5*vector.acceleration*deltaSec*deltaSec,\n\t\tvelocity : vector.velocity + vector.acceleration*deltaSec,\n\t\tacceleration : vector.acceleration,\n\t\ttimestamp : ts\n\t};\n};\n\n\n/*\n    Calculate direction of motion at time ts\n    1 : forwards, -1 : backwards: 0, no movement\n*/\nexport function calculateDirection(vector, ts) {\n    /*\n      Given initial vector calculate direction of motion at time t\n      (Result is valid only if (t > vector[T]))\n      Return Forwards:1, Backwards -1 or No-direction (i.e. no-motion) 0.\n      If t is undefined - t is assumed to be now.\n    */\n    let freshVector;\n    if (ts == undefined) {\n        freshVector = vector;\n    } else {\n        freshVector = calculateVector(vector, ts);\n    }\n    // check velocity\n    let direction = cmp(freshVector.velocity, 0.0);\n    if (direction === 0) {\n        // check acceleration\n        direction = cmp(vector.acceleration, 0.0);\n    }\n    return direction;\n};\n\n\n/*\n    isMoving\n\n    returns true if motion is moving else false\n*/\nexport function isMoving(vector) {\n    return (vector.velocity !== 0.0 || vector.acceleration !== 0.0);\n};\n\n\n/*******************************************************************\n RANGE\n*******************************************************************/\n\n//\tRANGE STATE is used for managing/detecting range violations.\nexport const RangeState = Object.freeze({\n    INIT : \"init\",\n    INSIDE: \"inside\",\n    OUTSIDE_LOW: \"outsidelow\",\n    OUTSIDE_HIGH: \"outsidehigh\"\n});\n\n/*\n\tA snapshot vector is checked with respect to range,\n\tcalclulates correct RangeState (i.e. INSIDE|OUTSIDE)\n*/\nexport function correctRangeState(vector, range) {\n    const {position: p, velocity: v, acceleration: a} = vector;\n\tif (p > range[1]) return RangeState.OUTSIDE_HIGH;\n\tif (p < range[0]) return RangeState.OUTSIDE_LOW;\n\t// corner cases\n\tif (p === range[1]) {\n\t\tif (v > 0.0) return RangeState.OUTSIDE_HIGH;\n\t\tif (v === 0.0 && a > 0.0) return RangeState.OUTSIDE_HIGH;\n\t} else if (p === range[0]) {\n\t    if (v < 0.0) return RangeState.OUTSIDE_LOW;\n\t    if (v == 0.0 && a < 0.0) return RangeState.OUTSIDE_HIGH;\n\t}\n\treturn RangeState.INSIDE;\n};\n\n/*\n\n\tA snapshot vector is checked with respect to range.\n\tReturns vector corrected for range violations, or input vector unchanged.\n*/\nexport function checkRange(vector, range) {\n\tconst state = correctRangeState(vector, range);\n\tif (state !== RangeState.INSIDE) {\n\t\t// protect from range violation\n\t\tvector.velocity = 0.0;\n\t\tvector.acceleration = 0.0;\n\t\tif (state === RangeState.OUTSIDE_HIGH) {\n\t\t\tvector.position = range[1];\n\t\t} else vector.position = range[0];\n\t}\n\treturn vector;\n};\n\n\n/*\n    Return tsEndpoint of (first) range intersect if any.\n*/\nexport function rangeIntersect(vector, range) {\n    let t0 = vector.timestamp;\n    // Time delta to hit rangeLeft\n    let deltaLeft = calculateMinPositiveRealSolution(vector, range[0]);\n    // Time delta to hit rangeRight\n    let deltaRight = calculateMinPositiveRealSolution(vector, range[1]);\n    // Pick the appropriate solution\n    if (deltaLeft !== undefined && deltaRight !== undefined) {\n        if (deltaLeft < deltaRight) {\n            return [t0 + deltaLeft, range[0]];\n        }\n        else\n            return [t0 + deltaRight, range[1]];\n    }\n    else if (deltaLeft !== undefined)\n        return [t0 + deltaLeft, range[0]];\n    else if (deltaRight !== undefined)\n        return [t0 + deltaRight, range[1]];\n    else return [undefined, undefined];\n}\n\n\n/*******************************************************************\n EQUATIONS\n*******************************************************************/\n\n/*\n    hasRealSolution\n\n    Given motion determined from p,v,a,t.\n    Determine if equation p(t) = p + vt + 0.5at^2 = x\n    has solutions for some real number t.\n*/\n\nfunction hasRealSolution (p,v,a,x) {\n\tif ((Math.pow(v,2) - 2*a*(p-x)) >= 0.0) return true;\n\telse return false;\n};\n\n\n/*\n    calculateRealSolution\n\n    Given motion determined from p,v,a,t.\n    Determine if equation p(t) = p + vt + 0.5at^2 = x\n    has solutions for some real number t.\n    Calculate and return real solutions, in ascending order.\n*/\n\nfunction calculateRealSolutions(p,v,a,x) {\n\t// Constant Position\n\tif (a === 0.0 && v === 0.0) {\n\t    if (p != x) return [];\n\t    else return [0.0];\n\t}\n\t// Constant non-zero Velocity\n\tif (a === 0.0) return [(x-p)/v];\n\t// Constant Acceleration\n\tif (hasRealSolution(p,v,a,x) === false) return [];\n\t// Exactly one solution\n\tconst discriminant = v*v - 2*a*(p-x);\n\tif (discriminant === 0.0) {\n\t    return [-v/a];\n\t}\n\tconst sqrt = Math.sqrt(Math.pow(v,2) - 2*a*(p-x));\n\tconst d1 = (-v + sqrt)/a;\n\tconst d2 = (-v - sqrt)/a;\n\treturn [Math.min(d1,d2),Math.max(d1,d2)];\n};\n\n\n/*\n    calculatePositiveRealSolutions\n\n    Given motion determined from p,v,a,t.\n    Determine if equation p(t) = p + vt + 0.5at^2 = x\n    has solutions for some real number t.\n    Calculate and return positive real solutions, in ascending order.\n*/\n\nfunction calculatePositiveRealSolutions(p,v,a,x) {\n\tconst res = calculateRealSolutions(p,v,a,x);\n\tif (res.length === 0) return [];\n\telse if (res.length == 1) {\n\t    if (res[0] > 0.0) {\n\t\t\treturn [res[0]];\n\t    }\n\t    else return [];\n\t}\n\telse if (res.length == 2) {\n\t    if (res[1] < 0.0) return [];\n\t    if (res[0] > 0.0) return [res[0], res[1]];\n\t    if (res[1] > 0.0) return [res[1]];\n\t    return [];\n\t}\n\telse return [];\n};\n\n\n/*\n    calculateMinPositiveRealSolution\n\n    Given motion determined from p,v,a,t.\n    Determine if equation p(t) = p + vt + 0.5at^2 = x\n    has solutions for some real number t.\n    Calculate and return the least positive real solution.\n*/\nfunction calculateMinPositiveRealSolution(vector, x) {\n    const {position: p, velocity: v, acceleration: a} = vector;\n\tconst res = calculatePositiveRealSolutions(p,v,a,x);\n\tif (res.length === 0) {\n        return;\n    }\n\telse return res[0];\n};\n\n\n/*\n    calculateDelta\n\n\n    Given motion determined from p0,v0,a0 (initial conditions or snapshot),\n    Supply two posisions, posBefore < p0 < posAfter.\n    Calculate which of these positions will be reached first,\n    if any, by the movement described by the vector.\n    In addition, calculate when this position will be reached.\n    Result will be expressed as time delta relative to t0, if solution exists,\n    and a flag to indicate Before (false) or After (true)\n    Note: t1 == (delta + t0) is only guaranteed to be in the\n    future as long as the function\n    is evaluated at time t0 or immediately after.\n*/\nexport function calculateDelta(vector, range) {\n\t// Time delta to hit posBefore\n\tlet deltaBeforeSec = calculateMinPositiveRealSolution(vector, range[0]);\n\t// Time delta to hit posAfter\n\tlet deltaAfterSec = calculateMinPositiveRealSolution(vector, range[1]);\n    // Infinity is no good solution\n    if (deltaBeforeSec == Infinity) {\n        deltaBeforeSec = undefined;\n    }\n    if (deltaAfterSec == Infinity) {\n        deltaAfterSec = undefined;\n    }\n    // Pick the appropriate solution\n\tif (deltaBeforeSec !== undefined && deltaAfterSec !== undefined) {\n\t    if (deltaBeforeSec < deltaAfterSec)\n\t\t\treturn [deltaBeforeSec, range[0]];\n\t    else\n\t\t\treturn [deltaAfterSec, range[1]];\n\t}\n\telse if (deltaBeforeSec !== undefined)\n\t    return [deltaBeforeSec, range[0]];\n\telse if (deltaAfterSec !== undefined)\n\t    return [deltaAfterSec, range[1]];\n\telse return [undefined, undefined];\n};\n\n\n/*******************************************************************\n TIME_INTERVAL POS_INTERVAL\n*******************************************************************/\n\n/*\n    posInterval_from_timeInterval\n\n    given\n    - a time interval\n    - a vector describing motion within the time interval\n    figure out the smallest interval (of positions)\n    that covers all possible positions during the time interval\n*/\n\nexport function posInterval_from_timeInterval (timeInterval, vector) {\n\n    /*\n        no motion or singular time interval\n    */\n    if (!isMoving(vector) || timeInterval.singular) {\n        return new Interval(vector.position);\n    }\n\n    let t0 = timeInterval.low;\n    let t1 = timeInterval.high;\n    let t0_closed = timeInterval.lowInclude;\n    let t1_closed = timeInterval.highInclude;\n\n    let vector0 = calculateVector(vector, t0);\n    let p0 = vector0.position;\n    let v0 = vector0.velocity;\n    let a0 = vector0.acceleration;\n    let p1 = calculateVector(vector, t1).position;\n\n    if (a0 != 0) {\n\n        /*\n            motion, with acceleration\n\n            position over time is a parabola\n            figure out if extrema happens to occor within\n            timeInterval. If it does, extreme point is endpoint in\n            position Interval. p0 or p1 will be the other\n            interval endpoint.\n\n            I extreme point is not occuring within timeInterval,\n            interval endpoint will be p0 and p1.\n\n            general parabola\n            y = Ax*x + Bx + C\n            extrema (x,y) : x = - B/2A, y = -B*B/4A + C\n\n            where t0 <= t <= t1\n            p(t) = 0.5*a0*(t-t0)*(t-t0) + v0*(t-t0) + p0,\n\n            A = a0/2, B = v0, C = p0\n\n            extrema (t_extrema, p_extrema):\n            t_extrem = -v0/a0 + t0\n            p_extrem = -v0*v0/(2*a0) + p0\n\n        */\n        let t_extrem = -v0/a0 + t0;\n        if (timeInterval.covers_endpoint(t_extrem)) {\n            let p_extrem = -v0*v0/(2.0*a0) + p0;\n            // maximal point reached in time interval\n            if (a0 > 0.0) {\n                // p_extrem is minimum\n                // figure out if p0 or p1 is maximum\n                if (p0 < p1) {\n                    return new Interval(p_extrem, p1, true, t1_closed);\n                } else {\n                    return new Interval(p_extrem, p0, true, t0_closed);\n                }\n            } else {\n                // p_extrem is maximum\n                // figure out if p0 or p1 is minimum\n                if (p0 < p1) {\n                    return new Interval(p0, p_extrem, t0_closed, true);\n                } else {\n                    return new Interval(p1, p_extrem, t1_closed, true);\n                }\n            }\n        }\n    }\n\n    /*\n        Motion, with or without acceleration,\n        yet with no extreme points within interval\n\n        positition monotonic increasing (forward velocity)\n        or decreasing (backward velocity)\n\n        extrem positions are associated with p0 and p1.\n    */\n\n    if (p0 < p1) {\n        // forward\n        return new Interval(p0, p1, t0_closed, t1_closed);\n    } else {\n        // backward\n        return new Interval(p1, p0, t1_closed, t0_closed);\n    }\n}\n\n\n/*\n    time endpoint and pos endpoints.\n\n    time is always increasing even when position\n    is decreasing. When making a timeEndpoint from\n    a posEndpoin the right/left aspect of the endpoint\n    needs to be flipped.\n\n    ts - the value of the timeEndpoint, ie. the time when\n         motion will pass over posEndpoing\n    direction - direction of motion at time ts\n*/\n\nexport function timeEndpoint_from_posEndpoint(posEndpoint, ts, direction) {\n    let [pos, right, close, singular] = posEndpoint;\n    // flip right/left if direction is backwards\n    if (direction < 0 && right !== undefined) {\n        right = !right\n    }\n    return [ts, right, close, singular];\n}\n\n\n/*******************************************************************\n ENDPOINT EVENTS\n*******************************************************************/\n\n/*\n    endpointEvents\n\n    Given a motion and a set of endpoing, calculate when\n    the motion will pass by each endpoing.\n\n    Given\n    - timeInterval\n    - posInterval\n    - vector describing motion within timeInterval\n    - list of endpointItems\n\n    endpointItem\n    {\n        endpoint: [value, high, closed, singular],\n        cue: {\n            key: \"mykey\",\n            interval: new Interval(...),\n            data: {...}\n        }\n    }\n\n    Creates eventItem by adding to endpointItem\n    - tsEndpoint : timestamp endpoint (future) when motion will pass the endpoint\n    - direction: true if motion passes endpoint while moving forward\n\n    EventItems will be sorted by ts\n\n    Issue:\n\n        timeInterval [t0, t1)\n        posinterval [p0, p1)\n\n        Consider event at time t1 concerning endpoint p1)\n        This will be outside the timeInterval, but inside\n        the posInterval.\n\n        Conversely, it will be inside the next timeInterval,\n        but not the next posInterval.\n\n        This is a problem - like falling between chairs.\n\n        Resolve this by representing timestamps as endpoints too\n\n*/\n\nexport function endpointEvents (timeInterval, posInterval, vector, endpointItems) {\n\n    /*\n        no motion or singular time interval\n    */\n    if (timeInterval.singular) {\n        throw new Error(\"getEventItems: timeInterval is singular\");\n    }\n    if (!isMoving(vector)) {\n        throw new Error(\"getEventItems: no motion\")\n    }\n\n    let p0 = vector.position;\n    let v0 = vector.velocity;\n    let a0 = vector.acceleration;\n    let t0 = vector.timestamp;\n\n    let value, ts, deltas;\n    let tsEndpoint, direction;\n    let eventItems = [];\n\n    endpointItems.forEach(function(item) {\n        // check that endpoint is inside given posInterval\n        if (!posInterval.covers_endpoint(item.endpoint)) {\n            return;\n        }\n        value = item.endpoint[0];\n        // check if equation has any solutions\n        if (!hasRealSolution(p0, v0, a0, value)) {\n            return;\n        }\n        // find time when motion will pass value\n        // time delta is relative to t0\n        // could be both in history or future\n        deltas = calculateRealSolutions(p0,v0,a0, value);\n        // include any timestamp within the timeinterval\n        deltas.forEach(function(delta) {\n            ts = t0 + delta;\n            direction = calculateDirection(vector, ts);\n            tsEndpoint = timeEndpoint_from_posEndpoint(item.endpoint, ts, direction);\n            if (timeInterval.covers_endpoint(tsEndpoint)){\n                item.tsEndpoint = tsEndpoint;\n                item.direction = direction;\n                eventItems.push(item);\n            }\n        });\n    });\n\n    // sort eventItems according to tsEndpoints\n    const cmp = function (a,b) {\n        return endpoint.cmp(a.tsEndpoint, b.tsEndpoint);\n    };\n    eventItems.sort(cmp);\n    return eventItems;\n};\n\n\n/*******************************************************************\n MOTION TRANSITION\n*******************************************************************/\n\n/*\n    Figure the nature of the transition from one motion to another,\n    i.e. when old_vector is replaced by new_vector.\n\n    The time when this transition occured is given bey\n    new_vector.timestamp, by definition.\n\n    - was moving (boolean) - true if moving before change\n    - is moving (boolean) - true if moving after change\n    - pos changed (boolean) - true if position was changed instantaneously\n    - move changed (boolean) - true if movement was changed instantaneously\n\n    report changed in two independent aspects\n    - change in position (i.e. discontinuity in position)\n    - change in movement (i.e. starting, stopping, changed)\n\n    These are represented as\n    - PosDelta\n    - MoveDelta\n\n    return [PosDelta, MoveDelta]\n*/\n\n\nexport class MotionDelta {\n\n\n    static PosDelta = Object.freeze({\n        NOOP: 0,                // no change in position\n        CHANGE: 1               // change in position\n    });\n\n\n    static MoveDelta = Object.freeze({\n        NOOP: 0,                // no change in movement, not moving\n        NOOP_MOVING: 1,         // no change in movement, moving\n        START: 2,               // not moving -> moving\n        CHANGE: 3,              // keep moving, movement changed\n        STOP: 4                 // moving -> not moving\n    });\n\n    constructor (old_vector, new_vector) {\n        let ts = new_vector.timestamp;\n        let is_moving = isMoving(new_vector)\n        let init = (old_vector == undefined || old_vector.position == undefined);\n        const PosDelta = MotionDelta.PosDelta;\n        const MoveDelta = MotionDelta.MoveDelta;\n\n        if (init) {\n            /*\n                Possible to introduce\n                PosDelta.INIT here instead of PosDelta.CHANGE\n                Not sure if this is needed.\n            */\n            if (is_moving) {\n                this._mc = [PosDelta.CHANGE, MoveDelta.START];\n            } else {\n                this._mc = [PosDelta.CHANGE, MoveDelta.NOOP];\n            }\n        } else {\n            let was_moving = isMoving(old_vector);\n            let end_vector = calculateVector(old_vector, ts);\n            let start_vector = calculateVector(new_vector, ts);\n\n            // position change\n            let pos_changed = (end_vector.position != start_vector.position);\n            let pct = (pos_changed) ? PosDelta.CHANGE : PosDelta.NOOP;\n\n            // movement change\n            let mct;\n            if (was_moving && is_moving) {\n                let vel_changed = (end_vector.velocity != start_vector.velocity);\n                let acc_changed = (end_vector.acceleration != start_vector.acceleration);\n                let move_changed = (vel_changed || acc_changed);\n                if (move_changed) {\n                    mct = MoveDelta.CHANGE;\n                } else {\n                    mct = MoveDelta.NOOP_MOVING;\n                }\n            } else if (!was_moving && is_moving) {\n                mct = MoveDelta.START;\n            } else if (was_moving && !is_moving) {\n                mct = MoveDelta.STOP;\n            } else if (!was_moving && !is_moving) {\n                mct = MoveDelta.NOOP;\n            }\n            this._mc = [pct, mct];\n        }\n    }\n\n    get posDelta () {\n        return this._mc[0];\n    }\n\n    get moveDelta () {\n        return this._mc[1]\n    }\n\n    toString() {\n        const PosDelta = MotionDelta.PosDelta;\n        const MoveDelta = MotionDelta.MoveDelta;\n        let str = (this.posDelta == PosDelta.CHANGE) ? \"jump, \" : \"\";\n        if (this.moveDelta == MoveDelta.START) {\n            str += \"movement started\";\n        } else if (this.moveDelta == MoveDelta.CHANGE) {\n            str += \"movement changed\";\n        } else if (this.moveDelta == MoveDelta.STOP) {\n            str += \"movement stopped\";\n        } else if (this.moveDelta == MoveDelta.NOOP_MOVING) {\n            str += \"movement noop - moving\";\n        } else if (this.moveDelta == MoveDelta.NOOP) {\n            str += \"movement noop - not moving\";\n        }\n        return str;\n    }\n}\n\n\n// return module object\n/*\nexport default {\n    isMoving,\n    // equalVectors,\n    // copyVector,\n\tcalculateVector,\n\tcalculateDirection,\n\t// calculateMinPositiveRealSolution,\n\tcalculateDelta,\n\t// correctRangeState,\n\t// checkRange,\n\t// RangeState,\n    posInterval_from_timeInterval,\n    endpointEvents,\n    rangeIntersect,\n    MotionDelta\n};\n*/\n\n","/*\n    Copyright 2020\n    Author : Ingar Arntzen\n\n    This file is part of the Timingsrc module.\n\n    Timingsrc is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    Timingsrc is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport Interval from './interval.js';\n\n// check if n is a number\nfunction is_number(n) {\n\tvar N = parseFloat(n);\n    return (n==N && !isNaN(N));\n};\n\n\n/*\n    utility function for protecting against duplicates\n*/\nfunction unique(A) {\n    return [...new Set(A)];\n};\n\n\n\n/*\n    batch inserts and removes have two strategies\n    1) change-sort\n    2) splice\n\n    simple rule by measurement\n    splice is better for batchlength <= 100 for both insert and remove\n*/\nfunction resolve_approach(arrayLength, batchLength) {\n    if (arrayLength == 0) {\n        return \"sort\";\n    }\n    return (batchLength <= 100) ? \"splice\" : \"sort\";\n};\n\n\nclass BinarySearchError extends Error {\n\n    constructor(message) {\n        super(message);\n        this.name = \"BinarySearchError\";\n    }\n\n}\n\n\n/*\n\nBINARY SEARCH\n\n- based on sorted list of unique elements\n- implements protection against duplicates\n\n\nPublic API\n- update (remove_elements, insert_elements)\n- lookup (interval) - returns list for all elements\n- remove (interval) - removes elements within interval\n- has (element)     - returns true if element exists with value == element, else false\n- get (element)     - returns element with value if exists, else undefined\n- values ()         - returns iterable for all elements\n- indexOf(element)  - returns index of element\n- indexOfElements(elements)\n- getByIndex(index) - returns element at given index\n\n\n*/\n\nfunction cmp(a, b) {return a-b;};\n\n\nclass BinarySearch {\n\n    constructor(options) {\n        this.array = [];\n        this.options = options || {};\n    }\n\n\n    /**\n     * Binary search on sorted array\n     * @param {*} searchElement The item to search for within the array.\n     * @return {Number} The index of the element which defaults to -1 when not found.\n     */\n    binaryIndexOf(searchElement) {\n        let minIndex = 0;\n        let maxIndex = this.array.length - 1;\n        let currentIndex;\n        let currentElement;\n        while (minIndex <= maxIndex) {\n    \t\tcurrentIndex = (minIndex + maxIndex) / 2 | 0;\n    \t\tcurrentElement = this.array[currentIndex];\n            if (currentElement < searchElement) {\n                minIndex = currentIndex + 1;\n            } else if (currentElement > searchElement) {\n                maxIndex = currentIndex - 1;\n            } else {\n                // found\n    \t\t    return currentIndex;\n    \t\t}\n        }\n        // not found - indicate at what index the element should be inserted\n    \treturn ~maxIndex;\n\n        // NOTE : ambiguity\n\n        /*\n        search for an element that is less than array[0]\n        should return a negative value indicating that the element\n        was not found. Furthermore, as it escapes the while loop\n        the returned value should indicate the index that this element\n        would have had - had it been there - as is the idea of this bitwise\n        operator trick\n\n        so, it follows that search for value of minimum element returns 0 if it exists, and 0 if it does not exists\n        this ambiguity is compensated for in relevant methods\n        */\n    };\n\n\n    /*\n        utility function for resolving ambiguity\n    */\n    isFound(index, x) {\n        if (index > 0) {\n            return true;\n        }\n        if (index == 0 && this.array.length > 0 && this.array[0] == x) {\n            return true;\n        }\n        return false;\n    };\n\n    /*\n        returns index of value or -1\n    */\n    indexOf(x) {\n        var index = this.binaryIndexOf(x);\n        return (this.isFound(index, x)) ? index : -1;\n    };\n\n    indexOfElements(elements) {\n        let x, index;\n        let indexes = [];\n        for (let i=0; i<elements.length; i++) {\n            x = elements[i];\n            index = this.indexOf(x);\n            if (index > -1) {\n                indexes.push(index);\n            }\n        }\n        return indexes;\n    };\n\n    /*\n        element exists with value\n    */\n    has(x) {\n        return (this.indexOf(x) > -1) ? true : false;\n    };\n\n    get(index) {\n        return this.array[index];\n    };\n\n\n\n    /*\n        REMOVE\n        Removes all elements with given values\n        search for each one and splice remove them individually\n        (reverse order)\n\n        INSERT\n        binarysearch and splice\n        insert - binarysearch and splice\n\n        WARNING - there should be no need to insert elements that are already\n        present in the array. This function drops such duplicates\n    */\n    _update_splice(to_remove, to_insert, options) {\n\n        // REMOVE\n        if (this.array.length > 0) {\n            let indexes = this.indexOfElements(to_remove);\n            /*\n                sort indexes to make sure we are removing elements\n                in backwards order\n                optimization\n                - if elements were sorted in the first place this should not be necessary\n            */\n            indexes.sort(function(a,b){return a-b;});\n            for (let i=indexes.length-1; i > -1; i--) {\n                this.array.splice(indexes[i], 1);\n            }\n        }\n\n        // INSERT\n        let x, index;\n        let len = to_insert.length;\n        for (let i=0; i<len; i++) {\n            x = to_insert[i];\n            index = this.binaryIndexOf(x);\n            if (!this.isFound(index, x)) {\n                // insert at correct place\n                this.array.splice(Math.abs(index), 0, x);\n            }\n        }\n    };\n\n\n    /*\n        remove - flag - sort to end and remove\n\n        Removes all elements with given values\n        - visit all elements - set their value to Infinite\n        - sort O(N) - native\n        - splice off Infinity values at end\n\n        insert - concat and sort\n\n        by doing both remove and insert in one operation,\n        sorting can be done only once.\n    */\n    _update_sort(to_remove, to_insert, options) {\n        // REMOVE\n        if (this.array.length > 0 && to_remove.length > 0) {\n            // visit all elements and set their value to undefined\n            // undefined values will be sorted to the end of the array\n            let indexes = this.indexOfElements(to_remove);\n            for (let i=0; i<indexes.length;i++) {\n                this.array[indexes[i]] = undefined;\n            }\n        }\n        // INSERT\n        // concat\n        this.array = this.array.concat(to_insert);\n        // sort\n        this.array.sort(cmp);\n        // remove undefined values at the end if any\n        if (to_remove.length > 0) {\n            let index = this.array.indexOf(undefined);\n            if (index > -1) {\n                this.array.splice(index, this.array.length-index);\n            }\n        }\n        // remove duplicates\n        this.array = unique(this.array);\n    };\n\n\n    /*\n        Update - removing and inserting elements in one operation\n\n        a single element should only be present once in the list, thus avoiding\n        multiple operations to one element. This is presumed solved externally.\n        - also objects must not be members of both lists.\n\n        - internally selects the best method - searchsplice or concatsort\n        - selection based on relative sizes of existing elements and new elements\n\n    */\n    update(to_remove, to_insert, options) {\n        let size = to_remove.length + to_insert.length;\n        if (size == 0) {\n            return;\n        }\n\n        // regular case\n        let approach = resolve_approach(this.array.length, size);\n        if (approach == \"splice\") {\n            this._update_splice(to_remove, to_insert, options);\n        } else if (approach == \"sort\"){\n            this._update_sort(to_remove, to_insert, options);\n        }\n    };\n\n\n    /*\n        Accessors\n    */\n\n    getMinimum() {\n        return (this.array.length > 0) ? this.array[0] : undefined;\n    };\n\n    getMaximum = function () {\n        return (this.array.length > 0) ? this.array[this.array.length - 1] : undefined;\n    };\n\n\n    /*\n        Internal search functions\n    */\n\n    /*\n       Find index of largest value less than x\n       Returns -1 if noe values exist that are less than x\n     */\n    ltIndexOf(x) {\n        var i = this.binaryIndexOf(x);\n        if (this.isFound(i, x)) {\n            /*\n                found - x is found on index i\n                consider element to the left\n                if we are at the left end of the array nothing is found\n                return -1\n            */\n            if (i > 0) {\n                return i-1;\n            } else {\n                return -1;\n            }\n        } else {\n            /*\n                not found - Math.abs(i) is index where x should be inserted\n                => Math.abs(i) - 1 is the largest value less than x\n            */\n            return Math.abs(i)-1;\n        }\n    };\n\n    /*\n       Find index of rightmost value less than x or equal to x\n       Returns -1 if noe values exist that are less than x or equal to x\n     */\n    leIndexOf(x) {\n        var i = this.binaryIndexOf(x);\n        if (this.isFound(i, x)) {\n            /*\n                element found\n            */\n            return i;\n        } else {\n            // not found - consider element to the left\n            i = Math.abs(i) - 1;\n            return (i >= 0) ? i : -1;\n        }\n    };\n\n    /*\n       \tFind index of leftmost value greater than x\n       \tReturns -1 if no values exist that are greater than x\n    */\n\n    gtIndexOf(x) {\n        var i = this.binaryIndexOf(x);\n        if (this.isFound(i, x)) {\n            /*\n                found - x is found on index i\n                if there are no elements to the right return -1\n            */\n            if (i < this.array.length -1) {\n                return i+1;\n            } else {\n                return -1;\n            }\n        } else {\n            /*\n                not found - Math.abs(i) is index where x should be inserted\n                => Math.abs(i) is the smallest value greater than x\n                unless we hit the end of the array, in which cas no smalles value\n                exist which is greater than x\n            */\n            let idx = Math.abs(i);\n            return (idx < this.array.length) ? idx : -1;\n        }\n    };\n\n\n    /*\n       Find index of leftmost value which is greater than x or equal to x\n       Returns -1 if noe values exist that are greater than x or equal to x\n     */\n\n    geIndexOf(x) {\n        var i = this.binaryIndexOf(x);\n        if (this.isFound(i, x)) {\n            /*\n                found element\n            */\n            return i;\n        } else {\n            // not found - consider the element where x would be inserted\n            i = Math.abs(i);\n            return (i<this.array.length) ? i : -1;\n        }\n    };\n\n    /*\n        lookup start and end indexes of elements within interval\n        for use with slice operation\n        returns undefined if no elements are found\n    */\n    lookupIndexes(interval) {\n        if (interval === undefined)\n            interval = new Interval(-Infinity, Infinity, true, true);\n        if (interval instanceof Interval === false)\n            throw new BinarySearchError(\"lookup requires Interval argument\");\n\n        // interval represents a single point\n        if (interval.singular) {\n            let index = this.indexOf(interval.low);\n            if (index > -1) {\n                return [index, index + 1];\n            } else {\n                return [undefined, undefined];\n            }\n        }\n\n        // regular non-singular interval\n        var start_index = -1, end_index = -1;\n        if (interval.lowInclude) {\n            start_index = this.geIndexOf(interval.low);\n        } else {\n            start_index = this.gtIndexOf(interval.low);\n        }\n        if (start_index === -1) {\n            return [undefined, undefined];\n        }\n        if (interval.highInclude) {\n            end_index = this.leIndexOf(interval.high);\n        } else {\n            end_index = this.ltIndexOf(interval.high);\n        }\n        if (end_index === -1) { // not reachable - I think\n            return [undefined, undefined];\n        }\n        return [start_index, end_index + 1];\n    };\n\n\n    /*\n        lookup by interval\n    */\n    lookup(interval) {\n        let [start, end] = this.lookupIndexes(interval);\n        return (start != undefined) ? this.array.slice(start, end) : [];\n    };\n\n    /*\n        remove by interval\n    */\n    remove(interval) {\n        let [start, end] = this.lookupIndexes(interval);\n        return (start != undefined) ? this.array.splice(start, end-start) : [];\n    };\n\n\n    slice(start, end) {\n        return this.array.slice(start, end);\n    };\n\n    splice(start, length) {\n        return this.array.splice(start, length);\n    };\n\n\n\n    /*\n        method for removing multiple closely placed elements in place\n        - removeList is sorted\n        - changes only affect the part of the index between first and last element\n        - move remaining elements to the left, remove elements with a single splice\n        - efficent if removelist references elements that are close to eachother\n    */\n\n    removeInSlice(removeList) {\n        if (removeList.length == 0){\n            return;\n        }\n        const low = removeList[0];\n        const high = removeList[removeList.length-1];\n        let [start, end] = this.lookupIndexes(new Interval(low, high, true, true));\n\n        let rd_ptr = start;\n        let wr_ptr = start;\n        let rm_ptr = 0;\n\n        while (rd_ptr < end) {\n            let rd_elem = this.array[rd_ptr];\n            let rm_elem = removeList[rm_ptr];\n            if (rd_elem < rm_elem) {\n                this.array[wr_ptr] = this.array[rd_ptr];\n                wr_ptr++;\n                rd_ptr++;\n            } else if (rd_elem == rm_elem) {\n                rd_ptr++;\n                rm_ptr++;\n            } else {\n                // rd_elem > rm_elem\n                rm_ptr++;\n            }\n            if (rm_ptr == removeList.length) {\n                break\n            }\n        }\n        this.array.splice(wr_ptr, rd_ptr-wr_ptr);\n    };\n\n\n    values() {\n        return this.array.values();\n    };\n\n    clear() {\n        this.array = [];\n    };\n\n    get length () {\n        return this.array.length;\n    }\n\n}\n\nexport default BinarySearch;\n\n\n\n","/*\n\tCopyright 2020\n\tAuthor : Ingar Arntzen\n\n\tThis file is part of the Timingsrc module.\n\n\tTimingsrc is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU Lesser General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tTimingsrc is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU Lesser General Public License for more details.\n\n\tYou should have received a copy of the GNU Lesser General Public License\n\talong with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n\n/*\n\tEvent\n\t- name: event name\n\t- publisher: the object which defined the event\n\t- init: true if the event suppports init events\n\t- subscriptions: subscriptins to this event\n\n*/\n\nclass Event {\n\n\tconstructor (publisher, name, options) {\n\t\toptions = options || {}\n\t\tthis.publisher = publisher;\n\t\tthis.name = name;\n\t\tthis.init = (options.init === undefined) ? false : options.init;\n\t\tthis.subscriptions = [];\n\t}\n\n\t/*\n\t\tsubscribe to event\n\t\t- subscriber: subscribing object\n\t\t- callback: callback function to invoke\n\t\t- options:\n\t\t\tinit: if true subscriber wants init events\n\t*/\n\tsubscribe (callback, options) {\n\t\tif (!callback || typeof callback !== \"function\") {\n\t\t\tthrow new Error(\"Callback not a function\", callback);\n\t\t}\n\t\tconst sub = new Subscription(this, callback, options);\n\t\tthis.subscriptions.push(sub);\n\t    // Initiate init callback for this subscription\n\t    if (this.init && sub.init) {\n\t    \tsub.init_pending = true;\n\t    \tlet self = this;\n\t    \tPromise.resolve().then(function () {\n\t    \t\tconst eArgs = self.publisher.eventifyInitEventArgs(self.name) || [];\n\t    \t\tfor (let eArg of eArgs) {\n\t    \t\t\tself.trigger(eArg, [sub], true);\n\t    \t\t}\n\t    \t\tsub.init_pending = false;\n\t    \t});\n\t    }\n\t\treturn sub\n\t}\n\n\t/*\n\t\ttrigger event\n\n\t\t- if sub is undefined - publish to all subscriptions\n\t\t- if sub is defined - publish only to given subscription\n\t*/\n\ttrigger (eArg, subs, init) {\n\t\tlet eInfo, ctx;\n\t\tfor (const sub of subs) {\n\t\t\t// ignore terminated subscriptions\n\t\t\tif (sub.terminated) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\teInfo = {\n\t\t\t\tsrc: this.publisher,\n\t\t\t\tname: this.name,\n\t\t\t\tsub: sub,\n\t\t\t\tinit: init\n\t\t\t}\n\t\t\tctx = sub.ctx || this.publisher;\n\t\t\ttry {\n\t\t\t\tsub.callback.call(ctx, eArg, eInfo);\n\t\t\t} catch (err) {\n\t\t\t\tconsole.log(`Error in ${this.name}: ${sub.callback} ${err}`);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\tunsubscribe from event\n\t- use subscription returned by previous subscribe\n\t*/\n\tunsubscribe(sub) {\n\t\tlet idx = this.subscriptions.indexOf(sub);\n\t\tif (idx > -1) {\n\t\t\tthis.subscriptions.splice(idx, 1);\n\t\t\tsub.terminate();\n\t\t}\n\t}\n}\n\n\n/*\n\tSubscription class\n*/\n\nclass Subscription {\n\n\tconstructor(event, callback, options) {\n\t\toptions = options || {}\n\t\tthis.event = event;\n\t\tthis.name = event.name;\n\t\tthis.callback = callback\n\t\tthis.init = (options.init === undefined) ? this.event.init : options.init;\n\t\tthis.init_pending = false;\n\t\tthis.terminated = false;\n\t\tthis.ctx = options.ctx;\n\t}\n\n\tterminate() {\n\t\tthis.terminated = true;\n\t\tthis.callback = undefined;\n\t\tthis.event.unsubscribe(this);\n\t}\n}\n\n\n/*\n\n\tEVENTIFY INSTANCE\n\n\tEventify brings eventing capabilities to any object.\n\n\tIn particular, eventify supports the initial-event pattern.\n\tOpt-in for initial events per event type.\n\n\teventifyInitEventArgs(name) {\n\t\tif (name == \"change\") {\n\t\t\treturn [this._value];\n\t\t}\n\t}\n\n*/\n\nexport function eventifyInstance (object) {\n\tobject.__eventify_eventMap = new Map();\n\tobject.__eventify_buffer = [];\n\treturn object;\n};\n\n\n/*\n\tEVENTIFY PROTOTYPE\n\n\tAdd eventify functionality to prototype object\n*/\n\nexport function eventifyPrototype(_prototype) {\n\n\tfunction eventifyGetEvent(object, name) {\n\t\tconst event = object.__eventify_eventMap.get(name);\n\t\tif (event == undefined) {\n\t\t\tthrow new Error(\"Event undefined\", name);\n\t\t}\n\t\treturn event;\n\t}\n\n\t/*\n\t\tDEFINE EVENT\n\t\t- used only by event source\n\t\t- name: name of event\n\t\t- options: {init:true} specifies init-event semantics for event\n\t*/\n\tfunction eventifyDefine(name, options) {\n\t\t// check that event does not already exist\n\t\tif (this.__eventify_eventMap.has(name)) {\n\t\t\tthrow new Error(\"Event already defined\", name);\n\t\t}\n\t\tthis.__eventify_eventMap.set(name, new Event(this, name, options));\n\t};\n\n\t/*\n\t\tON\n\t\t- used by subscriber\n\t\tregister callback on event.\n\t*/\n\tfunction on(name, callback, options) {\n\t\treturn eventifyGetEvent(this, name).subscribe(callback, options);\n\t};\n\n\t/*\n\t\tOFF\n\t\t- used by subscriber\n\t\tUn-register a handler from a specfic event type\n\t*/\n\tfunction off(sub) {\n\t\treturn eventifyGetEvent(this, sub.name).unsubscribe(sub);\n\t};\n\n\n\tfunction eventifySubscriptions(name) {\n\t\treturn eventifyGetEvent(this, name).subscriptions;\n\t}\n\n\n\n\t/*\n\t\tTrigger list of eventItems on object\n\n\t\teventItem:  {name:.., eArg:..}\n\n\t\tcopy all eventItems into buffer.\n\t\trequest emptying the buffer, i.e. actually triggering events,\n\t\tevery time the buffer goes from empty to non-empty\n\t*/\n\tfunction eventifyTriggerAll(eventItems) {\n\t\tif (eventItems.length == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// make trigger items\n\t\t// resolve non-pending subscriptions now\n\t\t// else subscriptions may change from pending to non-pending\n\t\t// between here and actual triggering\n\t\t// make list of [ev, eArg, subs] tuples\n\t\tlet triggerItems = eventItems.map((item) => {\n\t\t\tlet {name, eArg} = item;\n\t\t\tlet ev = eventifyGetEvent(this, name);\n\t\t\tlet subs = ev.subscriptions.filter(sub => sub.init_pending == false);\n\t\t\treturn [ev, eArg, subs];\n\t\t}, this);\n\n\t\t// append trigger Items to buffer\n\t\tconst len = triggerItems.length;\n\t\tconst buf = this.__eventify_buffer;\n\t\tconst buf_len = this.__eventify_buffer.length;\n\t\t// reserve memory - set new length\n\t\tthis.__eventify_buffer.length = buf_len + len;\n\t\t// copy triggerItems to buffer\n\t\tfor (let i=0; i<len; i++) {\n\t\t\tbuf[buf_len+i] = triggerItems[i];\n\t\t}\n\t\t// request emptying of the buffer\n\t\tif (buf_len == 0) {\n\t\t\tlet self = this;\n\t\t\tPromise.resolve().then(function() {\n\t\t\t\tfor (let [ev, eArg, subs] of self.__eventify_buffer) {\n\t\t\t\t\t// actual event triggering\n\t\t\t\t\tev.trigger(eArg, subs, false);\n\t\t\t\t}\n\t\t\t\tself.__eventify_buffer = [];\n\t\t\t});\n\t\t}\n\t}\n\n\t/*\n\t\tTrigger multiple events of same type (name)\n\t*/\n\tfunction eventifyTriggerAlike(name, eArgs) {\n\t\treturn this.eventifyTriggerAll(eArgs.map(eArg => {\n\t\t\treturn {name, eArg};\n\t\t}));\n\t}\n\n\t/*\n\t\tTrigger single event\n\t*/\n\tfunction eventifyTrigger(name, eArg) {\n\t\treturn this.eventifyTriggerAll([{name, eArg}]);\n\t}\n\n\t_prototype.eventifyDefine = eventifyDefine;\n\t_prototype.eventifyTrigger = eventifyTrigger;\n\t_prototype.eventifyTriggerAlike = eventifyTriggerAlike;\n\t_prototype.eventifyTriggerAll = eventifyTriggerAll;\n\t_prototype.eventifySubscriptions = eventifySubscriptions;\n\t_prototype.on = on;\n\t_prototype.off = off;\n};\n\n\n/*\n\tEvent Variable\n\n\tObjects with a single \"change\" event\n*/\n\nexport class EventVariable {\n\n\tconstructor (value) {\n\t\teventifyInstance(this);\n\t\tthis._value = value;\n\t\tthis.eventifyDefine(\"change\", {init:true});\n\t}\n\n\teventifyInitEventArgs(name) {\n\t\tif (name == \"change\") {\n\t\t\treturn [this._value];\n\t\t}\n\t}\n\n\tget value () {return this._value};\n\tset value (value) {\n\t\tif (value != this._value) {\n\t\t\tthis._value = value;\n\t\t\tthis.eventifyTrigger(\"change\", value);\n\t\t}\n\t}\n}\neventifyPrototype(EventVariable.prototype);\n\n/*\n\tEvent Boolean\n\n\n\tNote : implementation uses falsiness of input parameter to constructor and set() operation,\n\tso eventBoolean(-1) will actually set it to true because\n\t(-1) ? true : false -> true !\n*/\n\nexport class EventBoolean extends EventVariable {\n\tconstructor(value) {\n\t\tsuper(Boolean(value));\n\t}\n\n\tset value (value) {\n\t\tsuper.value = Boolean(value);\n\t}\n\tget value () {return super.value};\n}\n\n\n/*\n\tmake a promise which is resolved when EventBoolean changes\n\tvalue.\n*/\nexport function makePromise(eventObject, conditionFunc) {\n\tconditionFunc = conditionFunc || function(val) {return val == true};\n\treturn new Promise (function (resolve, reject) {\n\t\tlet sub = eventObject.on(\"change\", function (value) {\n\t\t\tif (conditionFunc(value)) {\n\t\t\t\tresolve(value);\n\t\t\t\teventObject.off(sub);\n\t\t\t}\n\t\t});\n\t});\n};\n\n// module api\nexport default {\n\teventifyPrototype,\n\teventifyInstance,\n\tEventVariable,\n\tEventBoolean,\n\tmakePromise\n};\n\n","/*\n    Copyright 2020\n    Author : Ingar Arntzen\n\n    This file is part of the Timingsrc module.\n\n    Timingsrc is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    Timingsrc is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport eventify from './eventify.js';\n\n/*******************************************************************\n BASE OBSERVABLE MAP\n*******************************************************************/\n\n/*\n    This is a base class for observable map\n*/\n\nclass ObservableMap {\n\n    constructor (options={}) {\n        \n        this.options = options;\n\n        // Events\n        eventify.eventifyInstance(this);\n        this.eventifyDefine(\"batch\", {init:true});\n        this.eventifyDefine(\"change\", {init:true});\n        this.eventifyDefine(\"remove\", {init:false});\n    }\n\n    /**\n     *  Abstract accessor to datasource backing implementation\n     *  of observable map. Typically this is an instance of Map() class.\n     * \n     *  Must be implemented by subclass. \n     */\n\n    get datasource () {\n        throw new Error(\"not implemented\");\n    }\n\n    /***************************************************************\n     ORDERING\n    ***************************************************************/\n\n    sortOrder(options={}) {\n        // sort options override constructor options\n        let {order=this.options.order} = options;\n        if (typeof order == \"function\") {\n            return order;\n        }       \n    }\n\n    /* \n        Sort values of Observable map\n        ordering can be overidden by specifying option <order>\n        fallback to order from constructor\n        noop if no ordering is defined\n    */\n    sortValues(iter, options={}) {\n        let order = this.sortOrder(options);\n        if (typeof order == \"function\") {\n            // sort\n            // if iterable not array - convert into array ahead of sorting\n            let arr = (Array.isArray(iter)) ? iter : [...iter];\n            return arr.sort(order);\n        } else {\n            // noop\n            return iter;\n        }\n    }\n\n    /* \n        Sort items (in-place) by value {new:value, old:value} using\n        ordering function for values\n    */\n    sortItems(items) {\n        let order = this.sortOrder();        \n        if (typeof order == \"function\") {\n            items.sort(function(item_a, item_b) {\n                let cue_a = (item_a.new) ? item_a.new : item_a.old;\n                let cue_b = (item_b.new) ? item_b.new : item_b.old;\n                return order(cue_a, cue_b);\n            });\n        }\n    }\n\n    /***************************************************************\n     EVENTS\n    ***************************************************************/\n\n    /*\n        Eventify: immediate events\n    */\n    eventifyInitEventArgs(name) {\n        if (name == \"batch\" || name == \"change\") {\n            let items = [...this.datasource.entries()].map(([key, val]) => {\n                return {key:key, new:val, old:undefined};\n            });\n            // sort init items (if order defined)\n            this.sortItems(items);\n            return (name == \"batch\") ? [items] : items;\n        }\n    }\n\n    /*\n        Event Notification\n    */\n    _notifyEvents(items) {\n        // event notification\n        if (items.length == 0) {\n            return;\n        }\n        const has_update_subs = this.eventifySubscriptions(\"batch\").length > 0;\n        const has_remove_subs = this.eventifySubscriptions(\"remove\").length > 0;\n        const has_change_subs = this.eventifySubscriptions(\"change\").length > 0;\n        // update\n        if (has_update_subs) {\n            this.eventifyTrigger(\"batch\", items);\n        }\n        // change, remove\n        if (has_remove_subs || has_change_subs) {\n            for (let item of items) {\n                if (item.new == undefined && item.old != undefined) {\n                    if (has_remove_subs) {\n                        this.eventifyTrigger(\"remove\", item);\n                    }\n                } else {\n                    if (has_change_subs) {\n                        this.eventifyTrigger(\"change\", item);\n                    }\n                }\n            }\n        }\n    }\n\n\n    /***************************************************************\n     ACCESSORS\n    ***************************************************************/\n\n    get size () {\n        return this.datasource.size;\n    }\n\n    has(key) {\n        return this.datasource.has(key);\n    };\n\n    get(key) {\n        return this.datasource.get(key);\n    };\n\n    keys() {\n        return this.datasource.keys();\n    };\n\n    values() {\n        return this.datasource.values();\n    };\n\n    entries() {\n        return this.datasource.entries();\n    }\n\n\n    /***************************************************************\n     MODIFY\n    ***************************************************************/\n\n    set(key, value) {\n        let old = undefined;\n        if (this.datasource.has(key)) {\n            old = this.datasource.get(key);\n        }\n        this.datasource.set(key, value);\n        this._notifyEvents([{key: key, new:value, old: old}]);\n        return this;\n    }\n\n    delete(key) {\n        let result = false;\n        let old = undefined;\n        if (this.datasource.has(key)) {\n            old = this.datasource.get(key);\n            this.datasource.delete(key);\n            result = true;\n        }\n        this._notifyEvents([{key: key, new:undefined, old: old}]);\n        return result;\n    }\n\n    clear() {\n        // create change events for all cues\n        const items = [...this.datasource.entries()].map(([key, val]) => {\n            return {key: key, new: undefined, old: val};\n        })\n        // clear _map\n        this.datasource.clear();\n        // event notification\n        this._notifyEvents(items);\n    }\n\n}\n\neventify.eventifyPrototype(ObservableMap.prototype);\n\nexport default ObservableMap;\n","/*\n    Copyright 2020\n    Author : Ingar Arntzen\n\n    This file is part of the Timingsrc module.\n\n    Timingsrc is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    Timingsrc is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\n    Wraps the built in setTimeout to provide a\n    Timeout that does not fire too early.\n\n    Importantly, the Timeout object manages at most\n    one timeout.\n\n    - Given clock.now() returns a value in seconds.\n    - The timeout is set with and absolute timestamp,\n      not a delay.\n*/\n\nclass Timeout {\n\n    constructor (timingObject, callback) {\n        this.tid = undefined;\n        this.to = timingObject;\n        this.callback = callback;\n    }\n\n    isSet() {\n        return this.tid != undefined;\n    }\n\n    /*\n        set timeout to point in time (seconds)\n    */\n    setTimeout(target_ts, arg) {\n        if (this.tid != undefined) {\n            throw new Error(\"at most on timeout\");\n        }\n        let now = this.to.clock.now();\n        let delay = Math.max(target_ts - now, 0) * 1000;\n        this.tid = setTimeout(this.onTimeout.bind(this), delay, target_ts, arg);\n    }\n\n    /*\n        handle timeout intended for point in time (seconds)\n    */\n    onTimeout(target_ts, arg) {\n        if (this.tid != undefined) {\n            this.tid = undefined;\n            // check if timeout was too early\n            let now = this.to.clock.now()\n            if (now < target_ts) {\n                // schedule new timeout\n                this.setTimeout(target_ts, arg);\n            } else {\n                // handle timeout\n                this.callback(now, arg);\n            }\n        }\n    }\n\n    /*\n        cancel and clear timeout if active\n    */\n    clear() {\n        if (this.tid != undefined) {\n            clearTimeout(this.tid);\n            this.tid = undefined;\n        }\n    }\n}\n\nexport default Timeout;\n","/*\n\tCopyright 2015 Norut Northern Research Institute\n\tAuthor : Ingar Mhlum Arntzen\n\n\tThis file is part of the Timingsrc module.\n\n\tTimingsrc is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU Lesser General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tTimingsrc is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU Lesser General Public License for more details.\n\n\tYou should have received a copy of the GNU Lesser General Public License\n\talong with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\n\tMASTER CLOCK\n\n\n\tMasterClock is the reference clock used by TimingObjects.\n\n\tIt is implemented using performance.now,\n\tbut is skewed and rate-adjusted relative to this local clock.\n\n\tThis allows it to be used as a master clock in a distributed system,\n\twhere synchronization is generally relative to some other clock than the local clock.\n\n\tThe master clock may need to be adjusted in time, for instance as a response to\n\tvarying estimation of clock skew or drift. The master clock supports an adjust primitive for this purpose.\n\n\tWhat policy is used for adjusting the master clock may depend on the circumstances\n\tand is out of scope for the implementation of the MasterClock.\n\tThis policy is implemented by the timing object. This policy may or may not\n\tprovide monotonicity.\n\n\tA change event is emitted every time the masterclock is adjusted.\n\n\tVector values define\n\t- position : absolute value of the clock in seconds\n\t- velocity : how many seconds added per second (1.0 exactly - or very close)\n\t- timestamp : timstamp from local system clock (performance) in seconds. Defines point in time where position and velocity are valid.\n\n\tIf initial vector is not provided, default value is\n\t{position: now, velocity: 1.0, timestamp: now};\n\timplying that master clock is equal to local clock.\n*/\n\nimport eventify from '../util/eventify.js';\n\n\n// Need a polyfill for performance,now as Safari on ios doesn't have it...\n(function(){\n    if (\"performance\" in window === false) {\n        window.performance = {};\n        window.performance.offset = new Date().getTime();\n    }\n    if (\"now\" in window.performance === false){\n      window.performance.now = function now(){\n        return new Date().getTime() - window.performance.offset;\n      };\n    }\n\t})();\n\n// local clock in seconds\nconst local_clock = {\n\tnow : function () {return performance.now()/1000.0;}\n};\n\nfunction calculateVector(vector, tsSec) {\n\tif (tsSec === undefined) tsSec = local_clock.now();\n\tvar deltaSec = tsSec - vector.timestamp;\n\treturn {\n\t\tposition : vector.position + vector.velocity*deltaSec,\n\t\tvelocity : vector.velocity,\n\t\ttimestamp : tsSec\n\t};\n};\n\nclass MasterClock {\n\n\tconstructor (options) {\n\t\tvar now = local_clock.now();\n\t\toptions = options || {};\n\t\tthis._vector  = {position: now, velocity: 1.0, timestamp: now};\n\t\t// event support\n\t\teventify.eventifyInstance(this);\n\t\tthis.eventifyDefine(\"change\", {init:false}); // define change event (no init-event)\n\t\t// adjust\n\t\tthis.adjust(options);\n\t};\n\n\t/*\n\t\tADJUST\n\t\t- could also accept timestamp for velocity if needed?\n\t\t- given skew is relative to local clock\n\t\t- given rate is relative to local clock\n\t*/\n\tadjust(options) {\n\t\toptions = options || {};\n\t\tvar now = local_clock.now();\n\t\tvar nowVector = this.query(now);\n\t\tif (options.skew === undefined && options.rate === undefined) {\n\t\t\treturn;\n\t\t}\n\t\tthis._vector = {\n\t\t\tposition : (options.skew !== undefined) ? now + options.skew : nowVector.position,\n\t\t\tvelocity : (options.rate !== undefined) ? options.rate : nowVector.velocity,\n\t\t\ttimestamp : nowVector.timestamp\n\t\t}\n\t\tthis.eventifyTrigger(\"change\");\n\t};\n\n\t/*\n\t\tNOW\n\t\t- calculates the value of the clock right now\n\t\t- shorthand for query\n\t*/\n\tnow() {\n\t\treturn calculateVector(this._vector, local_clock.now()).position;\n\t};\n\n\t/*\n\t\tQUERY\n\t\t- calculates the state of the clock right now\n\t\t- result vector includes position and velocity\n\t*/\n\tquery(now) {\n\t\treturn calculateVector(this._vector, now);\n\t};\n\n}\neventify.eventifyPrototype(MasterClock.prototype);\n\nexport default MasterClock;\n","/*\n\tCopyright 2015 Norut Northern Research Institute\n\tAuthor : Ingar Mhlum Arntzen\n\n\tThis file is part of the Timingsrc module.\n\n\tTimingsrc is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU Lesser General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tTimingsrc is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU Lesser General Public License for more details.\n\n\tYou should have received a copy of the GNU Lesser General Public License\n\talong with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\nimport MasterClock from './masterclock.js';\nimport {calculateVector, checkRange} from '../util/motionutils.js';\n\n\n/*\n\tINTERNAL PROVIDER\n\n\tTiming provider internal to the browser context\n\n\tUsed by timing objects as timingsrc if no timingsrc is specified.\n*/\n\nclass InternalProvider {\n\n\tconstructor (callback, options) {\n\t\toptions = options || {};\n\t\t// initialise internal state\n\t\tthis._clock = new MasterClock({skew:0});\n\t\tthis._range = [-Infinity, Infinity];\n\t\tthis._vector;\n\t\tthis._callback = callback;\n\t\t// options\n\t\toptions.timestamp = options.timestamp || this._clock.now();\n\t\tthis._process_update(options);\n\t};\n\n\t// internal clock\n\tget clock() {return this._clock;};\n\tget range() {return this._range;};\n\tget vector() {return this._vector;};\n\n\tisReady() {return true;};\n\n\t// update\n\t_process_update(arg) {\n\t\t// process arg\n\t\tlet {\n\t\t\tposition: pos,\n\t\t\tvelocity: vel,\n\t\t\tacceleration: acc,\n\t\t\ttimestamp: ts,\n\t\t\trange: range,\n\t\t\t...rest\n\t\t} = arg;\n\n\t\t// record state from current motion\n\t\tlet p = 0, v = 0, a = 0;\n\t\tif (this._vector != undefined) {\n\t\t\tlet nowVector = calculateVector(this._vector, ts);\n\t\t\tnowVector = checkRange(nowVector, this._range);\n\t\t\tp = nowVector.position;\n\t\t\tv = nowVector.velocity;\n\t\t\ta = nowVector.acceleration;\n\t\t}\n\n\t\t// fill in from current motion, for missing properties\n\t\tlet vector = {\n\t\t\tposition : (pos != undefined) ? pos : p,\n\t\t\tvelocity : (vel != undefined) ? vel : v,\n\t\t\tacceleration : (acc != undefined) ? acc : a,\n\t\t\ttimestamp : ts\n\t\t};\n\n\t\t// update range\n\t\tif (range != undefined) {\n\t\t\tlet [low, high] = range;\n\t\t\tif (low < high) {\n\t\t\t\tif (low != this._range[0] || high != this._range[1]) {\n\t\t\t\t\tthis._range = [low, high];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// check vector with respect to range\n\t\tvector = checkRange(vector, this._range);\n\t\t// save old vector\n\t\tthis._old_vector = this._vector;\n\t\t// update vector\n\t\tthis._vector = vector;\n\t\treturn {range, ...vector, ...rest};\n\t};\n\n\t// update\n\tupdate(arg) {\n\t\targ = this._process_update(arg);\n\t\treturn this._callback(arg);\n\t}\n\n\tclose() {\n\t\tthis._callback = undefined;\n\t}\n}\n\nexport default InternalProvider;\n\n","/*\n\tCopyright 2015 Norut Northern Research Institute\n\tAuthor : Ingar Mhlum Arntzen\n\n\tThis file is part of the Timingsrc module.\n\n\tTimingsrc is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU Lesser General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tTimingsrc is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU Lesser General Public License for more details.\n\n\tYou should have received a copy of the GNU Lesser General Public License\n\talong with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n\n*/\n\n\n\nimport MasterClock from './masterclock.js';\n\n\nfunction checkTimingProvider(obj){\n\tlet required = [\"on\", \"skew\", \"vector\", \"range\", \"update\"];\n\tfor (let prop of required) {\n\t\tif (!(prop in obj)) {\n\t\t\tthrow new Error(`TimingProvider ${obj} missing property ${prop}`);\n\t\t}\n\t}\n}\n\n\n/*\n\tEXTERNAL PROVIDER\n\n\tExternal Provider bridges the gap between the PROVIDER API (implemented by external timing providers)\n\tand the TIMINGSRC API\n\n\tObjects implementing the TIMINGSRC API may be used as timingsrc (parent) for another timing object.\n\n\t- wraps a timing provider external\n\t- handles some complexity that arises due to the very simple API of providers\n\t- implements a clock for the provider\n*/\n\nclass ExternalProvider {\n\n\tconstructor(provider, callback, options) {\n\t\tcheckTimingProvider(provider);\n\t\toptions = options || {};\n\n\t\tthis._provider = provider;\n\t\tthis._callback = callback;\n\t\tthis._range;\n\t\tthis._vector;\n\t\tthis._ready = false\n\n\t\t/*\n\t\t\tprovider clock (may fluctuate based on live skew estimates)\n\t\t*/\n\t\tthis._provider_clock;\n\t\t/*\n\t\t\tlocal clock\n\t\t\tprovider clock normalised to values of performance now\n\t\t\tnormalisation based on first skew measurement, so\n\t\t*/\n\t\tthis._clock;\n\n\n\t\t// register event handlers\n\t\tthis._provider.on(\"vectorchange\", this._onVectorChange.bind(this));\n\t\tthis._provider.on(\"skewchange\", this._onSkewChange.bind(this));\n\n\t\t// check if provider is ready\n\t\tlet self = this;\n\t\tif (this._provider.skew != undefined) {\n\t\t\tlet self = this;\n\t\t\tPromise.resolve(function () {\n\t\t\t\tself._onSkewChange();\n\t\t\t});\n\t\t}\n\t};\n\n\tisReady() {return this._ready;};\n\n\t// internal clock\n\tget clock() {return this._clock;};\n\tget range() {return this._range;};\n\n\n\t/*\n\t\t- local timestamp of vector is set for each new vector, using the skew available at that time\n\t\t- the vector then remains unchanged\n\t\t- skew changes affect local clock, thereby affecting the result of query operations\n\n\t\t- one could imagine reevaluating the vector as well when the skew changes,\n\t\t\tbut then this should be done without triggering change events\n\n\t\t- ideally the vector timestamp should be a function of the provider clock\n\t*/\n\n\tget vector() {\n\t\t// local_ts = provider_ts - skew\n\t\tlet local_ts = this._vector.timestamp - this._provider.skew;\n\t\treturn {\n\t\t\tposition : this._vector.position,\n\t\t\tvelocity : this._vector.velocity,\n\t\t\tacceleration : this._vector.acceleration,\n\t\t\ttimestamp : local_ts\n\t\t}\n\t}\n\n\n\t// internal provider object\n\tget provider() {return this._provider;};\n\n\n\t_onSkewChange() {\n\t\tif (!this._clock) {\n\t\t\tthis._provider_clock = new MasterClock({skew: this._provider.skew});\n\t\t\tthis._clock = new MasterClock({skew:0});\n\t\t} else {\n\t\t\tthis._provider_clock.adjust({skew: this._provider.skew});\n\t\t\t// provider clock adjusted with new skew - correct local clock similarly\n\t\t\t// current_skew = clock_provider - clock_local\n\t\t\tlet current_skew = this._provider_clock.now() - this._clock.now();\n\t\t\t// skew delta = new_skew - current_skew\n\t\t\tlet skew_delta = this._provider.skew - current_skew;\n\t\t\tthis._clock.adjust({skew: skew_delta});\n\t\t}\n\t\tif (!this.isReady() && this._provider.vector != undefined) {\n\t\t\t// just became ready\n\t\t\tthis._ready = true;\n\t\t\tthis._range = this._provider.range;\n\t\t\tthis._vector = this._provider.vector;\n\t\t\tlet eArg = {\n\t\t\t\trange: this.range,\n\t\t\t\t...this.vector,\n\t\t\t\tlive: false\n\t\t\t}\n\t\t\tthis._callback(eArg);\n\t\t}\n\t};\n\n\t_onVectorChange() {\n\t\tif (this._clock) {\n\t\t\t// is ready (onSkewChange has fired earlier)\n\t\t\tif (!this._ready) {\n\t\t\t\tthis._ready = true;\n\t\t\t}\n\t\t\tif (!this._range) {\n\t\t\t\tthis._range = this._provider.range;\n\t\t\t}\n\t\t\tthis._vector = this._provider.vector;\n\t\t\tlet eArg = {\n\t\t\t\trange: this.range,\n\t\t\t\t...this.vector\n\t\t\t}\n\t\t\tthis._callback(eArg);\n\t\t}\n\t};\n\n\n\t// update\n\t/*\n\t\tTODO - support setting range on provider\n\t\tTODO - suppport tunnel\n\t\tTODO - support onRangeChange from provider\n\t*/\n\tupdate(arg) {\n\t\tlet vector = {\n\t\t\tposition: arg.position,\n\t\t\tvelocity: arg.velocity,\n\t\t\tacceleration: arg.acceleration,\n\t\t\ttimestamp: arg.timestamp\n\t\t};\n\t\t// calc back to provider ts\n\t\t// local_ts = provider_ts - skew\n\t\tvector.timestamp = vector.timestamp + this._provider.skew;\n\t\tlet res = this._provider.update(vector);\n\t\t// return success\n\t\treturn true;\n\t};\n}\n\nexport default ExternalProvider;\n\n\n","/*\n\tCopyright 2020\n\tAuthor : Ingar Mhlum Arntzen\n\n\tThis file is part of the Timingsrc module.\n\n\tTimingsrc is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU Lesser General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tTimingsrc is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU Lesser General Public License for more details.\n\n\tYou should have received a copy of the GNU Lesser General Public License\n\talong with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\nimport eventify from '../util/eventify.js';\nimport Timeout from '../util/timeout.js';\nimport * as motionutils from '../util/motionutils.js';\nimport InternalProvider from './internalprovider.js';\nimport ExternalProvider from './externalprovider.js';\n\nconst MAX_NONCE = 10000;\n\nfunction getRandomInt() {\n \treturn Math.floor(Math.random() * MAX_NONCE);\n};\n\nfunction isTimingProvider(obj){\n\tlet required = [\"on\", \"skew\", \"vector\", \"range\", \"update\"];\n\tfor (let prop of required) {\n\t\tif (!(prop in obj)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nfunction checkRange(live, now, vector, range) {\n\tif (live) {\n\t\treturn motionutils.checkRange(vector, range);\n\t} else {\n\t\tlet now_vector = motionutils.calculateVector(vector, now);\n\t\treturn motionutils.checkRange(now_vector, range);\n\t}\n}\n\n\n\n/*\n\tTIMING BASE\n\n\tabstract base class for objects that may be used as timingsrc\n\n\tessential internal state\n\t- range, vector\n\n\texternal methods\n\tquery, update\n\n\tevents\n\ton/off \"change\", \"timeupdate\"\n\n\tinternal methods for range timeouts\n\n\tdefines internal processing steps\n\t- handleEvent(arg) <- from external timingobject\n\t\t- vector = onChange(vector)\n\t\t- process(vector) <- from timeout or preProcess\n\t- handleTimeout(arg) <- timeout on range restrictions\n\t- process (arg)\n\t\t- set internal vector, range\n\t\t- dispatchEvents(arg)\n\t\t- renew range timeout\n\t- dispatchEvent (arg)\n\t\t- emit change event and timeupdate event\n\t\t- turn periodic timeupdate on or off\n\n\tindividual steps in this structure may be specialized\n\tby subclasses (i.e. timing converters)\n*/\n\n\nclass TimingObject {\n\n\tconstructor (timingsrc, options) {\n\n\t\t// special support for options given as first and only argument\n\t\t// equivalent to new TimingObject(undefined, options)\n\t\t// in this case, timingsrc may be found in options\n\t\tif (timingsrc != undefined && options == undefined) {\n\t\t\tif (!(timingsrc instanceof TimingObject) && !isTimingProvider(timingsrc)) {\n\t\t\t\t// timingsrc is neither timing object nor timingprovider\n\t\t\t\t// assume timingsrc is options\n\t\t\t\toptions = timingsrc;\n\t\t\t\ttimingsrc = undefined;\n\t\t\t\tif (options.provider) {\n\t\t\t\t\ttimingsrc = options.provider;\n\t\t\t\t} else if (options.timingsrc) {\n\t\t\t\t\ttimingsrc = options.timingsrc;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t// options\n\t\toptions = options || {};\n\t\tthis.__options = options;\n\n\n\t\t// default timeout option\n\t\tif (options.timeout == undefined) {\n\t\t\toptions.timeout = true;\n\t\t}\n\n\t\t// cached vectors and range\n\t\tthis.__old_vector;\n\t\tthis.__vector;\n\t\tthis.__range = [-Infinity, Infinity];\n\n\t\t// range restriction timeout\n\t\tthis.__timeout = new Timeout(this, this.__handleTimeout.bind(this));\n\n\t\t// timeoutid for timeupdate event\n\t\tthis.__tid = undefined;\n\n\t\t// timingsrc\n\t\tthis.__timingsrc;\n\t\tthis.__sub;\n\n\t\t// update promises\n\t\tthis.__update_events = new Map();\n\n\t\t// readiness\n\t\tthis.__ready = new eventify.EventBoolean();\n\n\t\t// exported events\n\t\teventify.eventifyInstance(this);\n\t\tthis.eventifyDefine(\"timingsrc\", {init:true});\n\t\tthis.eventifyDefine(\"change\", {init:true});\n\t\tthis.eventifyDefine(\"rangechange\", {init:true});\n\t\tthis.eventifyDefine(\"timeupdate\", {init:true});\n\n\t\t// initialise timingsrc\n\t\tthis.__set_timingsrc(timingsrc, options);\n\t};\n\n\n\t/***************************************************************\n\n\t\tEVENTS\n\n\t***************************************************************/\n\n\t/*\n\t  \toverrides how immediate events are constructed\n\t  \tspecific to eventutils\n\t  \t- overrides to add support for timeupdate events\n\t*/\n\teventifyInitEventArgs(name) {\n\t\tif (this.__ready.value) {\n\t\t\tif (name == \"timingsrc\") {\n\t\t\t\tlet eArg = {\n\t\t\t\t\t...this.__vector,\n\t\t\t\t\trange: this.__range,\n\t\t\t\t\tlive:false\n\t\t\t\t}\n\t\t\t\treturn [eArg];\n\t\t\t} else if (name == \"timeupdate\") {\n\t\t\t\treturn [undefined];\n\t\t\t} else if (name == \"change\") {\n\t\t\t\treturn [this.__vector];\n\t\t\t} else if (name == \"rangechange\") {\n\t\t\t\treturn [this.__range];\n\t\t\t}\n\t\t}\n\t};\n\n\n\t/***************************************************************\n\n\t\tACCESSORS\n\n\t***************************************************************/\n\n\t// ready or not\n\tisReady() {return this.__ready.value;};\n\n\t// ready promise\n    get ready() {return eventify.makePromise(this.__ready);};\n\n    // range\n    get range() {\n    \t// copy\n    \treturn [this.__range[0], this.__range[1]];\n    };\n\n    // vector\n    get vector() {\n    \t// copy\n\t\treturn {\n\t\t\tposition : this.__vector.position,\n\t\t\tvelocity : this.__vector.velocity,\n\t\t\tacceleration : this.__vector.acceleration,\n\t\t\ttimestamp : this.__vector.timestamp\n\t\t};\n    };\n\n    // old vector\n    get old_vector() {return this.__old_vector;};\n\n    // delta\n    get delta() {\n    \treturn new motionutils.MotionDelta(this.__old_vector, this.__vector);\n    }\n\n\t// clock - from timingsrc or provider\n\tget clock() {return this.__timingsrc.clock};\n\n\tget version() {return 5;}\n\n\n\t/***************************************************************\n\n\t\tQUERY\n\n\t***************************************************************/\n\n\t// query\n\tquery() {\n\t\tif (this.__ready.value == false)  {\n\t\t\tthrow new Error(\"query before timing object is ready\");\n\t\t}\n\t\t// reevaluate state to handle range violation\n\t\tlet vector = motionutils.calculateVector(this.__vector, this.clock.now());\n\t\t// detect range violation - only if timeout is set {\n\t\tif (this.__timeout.isSet()) {\n\t\t\tif (vector.position < this.__range[0] || this.__range[1] < vector.position) {\n\t\t\t\t// emulate update event to trigger range restriction\n\t\t\t\tthis.__process({...this.onRangeViolation(vector)});\n\t\t\t}\n\t\t\t// re-evaluate query after state transition\n\t\t\treturn motionutils.calculateVector(this.__vector, this.clock.now());\n\t\t}\n\t\treturn vector;\n\t};\n\n\t// shorthand query\n\tget pos() {return this.query().position;};\n\tget vel() {return this.query().velocity;};\n\tget acc() {return this.query().acceleration;};\n\n\n\t/***************************************************************\n\n\t\tUPDATE\n\n\t***************************************************************/\n\n\t// internal update\n\t__update(arg) {\n\t\tif (this.__timingsrc instanceof TimingObject) {\n\t\t\treturn this.__timingsrc.__update(arg);\n\t\t} else {\n\t\t\t// provider\n\t\t\treturn this.__timingsrc.update(arg);\n\t\t}\n\t};\n\n\t// external update\n\tupdate(arg) {\n\t\t// check if noop\n\t\tlet ok = (arg.range != undefined);\n\t\tok = ok || (arg.position != undefined);\n\t\tok = ok || (arg.velocity != undefined);\n\t\tok = ok || (arg.acceleration != undefined);\n\t\tif (!ok) {\n\t\t\treturn Promise.resolve(arg);\n\t\t}\n\t\targ.tunnel = getRandomInt();\n\t\tif (arg.timestamp == undefined) {\n\t\t\targ.timestamp = this.clock.now();\n\t\t}\n\t\tlet event = new eventify.EventVariable();\n\t\tthis.__update_events.set(arg.tunnel, event);\n\t\tlet promise = eventify.makePromise(event, val => (val != undefined));\n\t\tthis.__update(arg);\n\t\treturn promise;\n\t}\n\n\n\t/***************************************************************\n\n\t\tCORE UPDATE PROCESSING\n\n\t***************************************************************/\n\n\t/*\n\t\tdo not override\n\t\thandle incoming change event\n\t\teArg = {vector:vector, range:range, live:true}\n\n\t\tsubclasses may specialise behaviour by overriding\n\t\tonVectorChange\n\n\t*/\n\t__handleEvent(arg) {\n\t\tlet {\n\t\t\trange,\n\t\t\tlive = true,\n\t\t\t...rest\n\t\t} = arg;\n\t\t// copy range object\n\t\tif (range != undefined) {\n\t\t\trange = [range[0], range[1]];\n\t\t}\n\t\t// new arg object\n\t\tlet _arg = {\n\t\t\trange,\n\t\t\tlive,\n\t\t\t...rest,\n\t\t};\n\t\t_arg = this.onUpdateStart(_arg);\n\t\tif (_arg != undefined) {\n\t\t\treturn this.__process(_arg);\n\t\t}\n\t};\n\n\t/*\n\t\tdo not override\n\t\thandle timeout\n\t*/\n\t__handleTimeout(now, vector) {\n\t\tthis.__process({...this.onRangeViolation(vector)});\n\t}\n\n\t/*\n\t\tcore processing step after change event or timeout\n\t\tassignes the internal vector\n\t*/\n\t__process(arg) {\n\t\tlet {\n\t\t\trange,\n\t\t\tposition,\n\t\t\tvelocity,\n\t\t\tacceleration,\n\t\t\ttimestamp,\n\t\t\tlive=true,\n\t\t\t...rest\n\t\t} = arg;\n\n\n\t\t// update range\n\t\tlet range_change = false;\n\t\tif (range != undefined) {\n\t\t\tlet [low, high] = range;\n\t\t\tif (low < high) {\n\t\t\t\tif (low != this.__range[0] || high != this.__range[1]) {\n\t\t\t\t\tthis.__range = [low, high];\n\t\t\t\t\trange = [low, high];\n\t\t\t\t\trange_change = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// update vector\n\t\tlet vector;\n\t\tlet vector_change = false;\n\t\tlet now = this.clock.now();\n\n\t\t// make sure vector is consistent with range\n\t\tif (position != undefined) {\n\t\t\t// vector change\n\t\t\tvector = {position, velocity, acceleration, timestamp};\n\t\t\t// make sure vector is consistent with range\n\t\t\tvector = checkRange(live, now, vector, this.__range);\n\t\t} else {\n\t\t\t// there is no vector change, but if range was changed,\n\t\t\t// the current vector must be checked for new range.\n\t\t\tif (range_change) {\n\t\t\t\tvector = checkRange(false, now, this.__vector, this.__range);\n\t\t\t}\n\t\t}\n\n\t\tif (vector != undefined) {\n\t\t\t// update vector\n\t\t\tif (this.__vector != undefined) {\n\t\t\t\tvector_change = !motionutils.equalVectors(vector, this.__vector);\n\t\t\t} else {\n\t\t\t\tvector_change = true;\n\t\t\t}\n\t\t\tif (vector_change) {\n\t\t\t\t// save old vector\n\t\t\t\tthis.__old_vector = this.__vector;\n\t\t\t\t// update vector\n\t\t\t\tthis.__vector = vector;\n\t\t\t}\n\t\t}\n\n\t\tlet _arg;\n\t\tif (range_change && vector_change) {\n\t\t\t_arg = {range, ...vector, live, ...rest};\n\t\t} else if (range_change) {\n\t\t\t_arg = {range, live, ...rest};\n\t\t} else if (vector_change) {\n\t\t\t_arg = {...vector, live, ...rest};\n\t\t} else {\n\t\t\t_arg = {live, ...rest};\n\t\t}\n\n\t\t// trigger events\n\t\tthis.__ready.value = true;\n\t\tthis.__dispatchEvents(_arg, range_change, vector_change);\n\t\t// renew timeout\n\t\tif (this.__options.timeout) {\n\t\t\tthis.__renewTimeout();\n\t\t}\n\t\t// release update promises\n\t\tif (_arg.tunnel != undefined) {\n\t\t\tlet event = this.__update_events.get(_arg.tunnel);\n\t\t\tif (event) {\n\t\t\t\tthis.__update_events.delete(_arg.tunnel);\n\t\t\t\tdelete _arg.tunnel;\n\t\t\t\tevent.value = _arg;\n\t\t\t}\n\t\t}\n\t\t// TODO\n\t\t// since externalprovider does not support tunnel yet\n\t\t// free all remaining promises\n\t\tfor (let event of this.__update_events.values()) {\n\t\t\tevent.value = {};\n\t\t}\n\t\tthis.onUpdateDone(_arg);\n\t\treturn _arg;\n\t};\n\n\t/*\n\t\tprocess a new vector applied in order to trigger events\n\t\toverriding this is only necessary if external change events\n\t\tneed to be suppressed,\n\t*/\n\t__dispatchEvents(arg, range_change, vector_change) {\n\t\tlet {\n\t\t\trange,\n\t\t\tposition,\n\t\t\tvelocity,\n\t\t\tacceleration,\n\t\t\ttimestamp\n\t\t} = arg;\n\t\t// trigger timingsrc events\n\t\tthis.eventifyTrigger(\"timingsrc\", arg);\n\t\t// trigger public change events\n\t\tif (vector_change) {\n\t\t\tlet vector = {position, velocity, acceleration, timestamp};\n\t\t\tthis.eventifyTrigger(\"change\", vector);\n\t\t}\n\t\tif (range_change) {\n\t\t\tthis.eventifyTrigger(\"rangechange\", range);\n\t\t}\n\t\t// trigger timeupdate events\n\t\tthis.eventifyTrigger(\"timeupdate\");\n\t\tlet moving = motionutils.isMoving(this.__vector);\n\t\tif (moving && this.__tid === undefined) {\n\t\t\tlet self = this;\n\t\t\tthis.__tid = setInterval(function () {\n\t\t\t\tself.eventifyTrigger(\"timeupdate\");\n\t\t\t}, 200);\n\t\t} else if (!moving && this.__tid !== undefined) {\n\t\t\tclearTimeout(this.__tid);\n\t\t\tthis.__tid = undefined;\n\t\t}\n\t};\n\n\n\t/***************************************************************\n\n\t\tSUBCLASS MAY OVERRIDE\n\n\t***************************************************************/\n\n\t/*\n\t\tmay be overridden\n\t*/\n\tonRangeViolation(vector) {return vector;};\n\n\t/*\n\t\tmay be overridden\n\t*/\n\tonUpdateStart(arg) {return arg;};\n\n\t/*\n\t\tmay be overridden\n\t*/\n\tonUpdateDone(arg) {};\n\n\n\t/***************************************************************\n\n\t\tTIMEOUTS\n\n\t***************************************************************/\n\n\t/*\n\t\trenew timeout is called during every processing step\n\t\tin order to recalculate timeouts.\n\n\t\t- optional vector - default is own vector\n\t\t- optional range - default is own range\n\t*/\n\t__renewTimeout(vector, range) {\n\t\tthis.__timeout.clear();\n\t\tlet timeout_vector = this.__calculateTimeoutVector(vector, range);\n\t\tif (timeout_vector == undefined) {\n\t\t\treturn;\n\t\t}\n\t\tthis.__timeout.setTimeout(timeout_vector.timestamp, timeout_vector);\n\t};\n\n\n\t/*\n\t\tcalculate a vector that will be delivered to _process().\n\t\tthe timestamp in the vector determines when it is delivered.\n\n\t\t- optional vector - default is own vector\n\t\t- optional range - default is own range\n\t*/\n\t__calculateTimeoutVector(vector, range) {\n\t\tvector = vector || this.__vector;\n\t\trange = range || this.__range;\n\t\tlet now = this.clock.now();\n\t\tlet now_vector = motionutils.calculateVector(vector, now);\n\t\tlet [delta, pos] = motionutils.calculateDelta(now_vector, range);\n\t\tif (delta == undefined) {\n\t\t\treturn;\n\t\t}\n\t\t// vector when range restriction will be reached\n\t\tlet timeout_vector = motionutils.calculateVector(vector, now + delta);\n\t\t// possibly avoid rounding errors\n\t\ttimeout_vector.position = pos;\n\t\treturn timeout_vector;\n\t};\n\n\n\t/***************************************************************\n\n\t\tTIMINGSRC\n\n\t***************************************************************/\n\n\t/*\n\n\t\ttimingsrc property and switching on assignment\n\n\t*/\n\t__clear_timingsrc() {\n\t\t// clear timingsrc\n\t\tif (this.__timingsrc != undefined) {\n\t\t\tif (this.__timingsrc instanceof TimingObject) {\n\t\t\t\tthis.__timingsrc.off(this.__sub);\n\t\t\t\tthis.__sub = undefined;\n\t\t\t\tthis.__timingsrc = undefined;\n\t\t\t} else {\n\t\t\t\t// provider\n\t\t\t\tthis.__timingsrc.close();\n\t\t\t\tthis.__timingsrc = undefined;\n\t\t\t}\n\t\t}\n\t}\n\n\t__set_timingsrc(timingsrc, options) {\n\t\t// set timingsrc\n\t\tlet callback = this.__handleEvent.bind(this);\n\t\tif (timingsrc instanceof TimingObject) {\n\t\t\t// timingsrc\n\t\t\tthis.__timingsrc = timingsrc;\n\t\t\tthis.__sub = this.__timingsrc.on(\"timingsrc\", callback);\n\t\t} else {\n\t\t\t// provider\n\t\t\tif (timingsrc == undefined) {\n\t\t\t\t// Internal Provider\n\t\t\t\tthis.__timingsrc = new InternalProvider(callback, options);\n\t\t\t} else {\n\t\t\t\t// External Provider\n\t\t\t\tthis.__timingsrc = new ExternalProvider(timingsrc, callback, options);\n\t\t\t}\n\t\t\t// emulating initial event from provider, causing\n\t\t\t// this timingobject to initialise\n\t\t\tif (this.__timingsrc.isReady()) {\n\t\t\t\tlet arg = {\n\t\t\t\t\trange: this.__timingsrc.range,\n\t\t\t\t\t...this.__timingsrc.vector,\n\t\t\t\t\tlive: false\n\t\t\t\t}\n\t\t\t\t// generate initial event\n\t\t\t\tcallback(arg);\n\t\t\t}\n\t\t}\n\t}\n\n\t__get_timingsrc() {\n\t\t// returns InternalProvider, ExternalProvider or TimingObject\n\t\treturn this.__timingsrc;\n\t}\n\n\tget timingsrc () {\n\t\t// returns TimingObject, Provider or undefined\n\t\tlet timingsrc = this.__get_timingsrc();\n\t\tif (timingsrc instanceof TimingObject) {\n\t\t\treturn timingsrc;\n\t\t} else if (timingsrc instanceof InternalProvider) {\n\t\t\treturn undefined;\n\t\t} else if (timingsrc instanceof ExternalProvider) {\n\t\t\treturn timingsrc._provider;\n\t\t} else {\n\t\t\tthrow new Error(\"illegal timingsrc\")\n\t\t}\n\t}\n\t\n\tset timingsrc(timingsrc) {\n\t\tthis.__clear_timingsrc();\n\t\tthis.__set_timingsrc(timingsrc);\n\t}\n\n}\n\neventify.eventifyPrototype(TimingObject.prototype);\n\nexport default TimingObject;\n\n\n\n","/*\n\tCopyright 2015 Norut Northern Research Institute\n\tAuthor : Ingar Mhlum Arntzen\n\n    This file is part of the Timingsrc module.\n\n    Timingsrc is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    Timingsrc is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\n\tSKEW CONVERTER\n\n\tSkewing the timeline by 2 means that the timeline position 0 of the timingsrc becomes position 2 of Converter.\n\n*/\n\n\nimport TimingObject from './timingobject.js';\n\n\nclass SkewConverter extends TimingObject {\n\n\tconstructor (timingsrc, skew, options) {\n\t\tsuper(timingsrc, options);\n\t\tthis._skew = skew;\n        this.eventifyDefine(\"skewchange\", {init:true});\n\t}\n\n    // extend\n    eventifyInitEventArgs(name) {\n        if (name == \"skewchange\") {\n            return [this._skew];\n        } else {\n            return super.eventifyInitEventArgs(name)\n        }\n    }\n\n\t// overrides\n\tonUpdateStart(arg) {\n        if (arg.range != undefined) {\n            arg.range[0] += this._skew;\n            arg.range[1] += this._skew;\n        }\n        if (arg.position != undefined) {\n\t\t\targ.position += this._skew;\n        }\n        return arg;\n\t};\n\n\t// overrides\n\tupdate(arg) {\n        if (arg.position != undefined) {\n\t\t\targ.position -= this._skew;\n        }\n        if (arg.range != undefined) {\n            let [low, high] = arg.range;\n            arg.range = [low - this._skew, high - this._skew];\n        }\n\t\treturn super.update(arg);\n\t};\n\n\tget skew() {return this._skew;};\n\n\tset skew(skew) {\n        if (skew != this._skew) {\n            // set skew and emulate new event from timingsrc\n\t\t\tthis._skew = skew;\n\t\t\tthis.__handleEvent({\n                ...this.__get_timingsrc().vector,\n                range: this.__get_timingsrc().range\n            });\n            this.eventifyTrigger(\"skewchange\", skew);\n        }\n\t}\n};\n\nexport default SkewConverter;\n","/*\n\tCopyright 2015 Norut Northern Research Institute\n\tAuthor : Ingar Mhlum Arntzen\n\n\tThis file is part of the Timingsrc module.\n\n\tTimingsrc is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU Lesser General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tTimingsrc is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU Lesser General Public License for more details.\n\n\tYou should have received a copy of the GNU Lesser General Public License\n\talong with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\n\tDELAY CONVERTER\n\n\tDelay Converter introduces a positive time delay on a source timing object.\n\n\tGenerally - if the source timing object has some value at time t,\n\tthen the delayConverter will provide the same value at time t + delay.\n\n\tSince the delay Converter is effectively replaying past events after the fact,\n\tit is not LIVE and not open to interactivity (i.e. update)\n\n*/\n\nimport TimingObject from './timingobject.js';\nimport Timeout from '../util/timeout.js';\n\n\nclass DelayConverter extends TimingObject {\n\tconstructor (timingObject, delay) {\n\t\tif (delay < 0) {throw new Error (\"negative delay not supported\");}\n\t\tif (delay === 0) {throw new Error (\"zero delay makes delayconverter pointless\");}\n\t\tsuper(timingObject);\n\t\t// fixed delay\n\t\tthis._delay = delay;\n\t\t// buffer\n\t\tthis._buffer = [];\n\t\t// timeoutid\n\t\tthis._timeout = new Timeout(this, this.__handleDelayed.bind(this));\n        this.eventifyDefine(\"delaychange\", {init:true});\n\t};\n\n    // extend\n    eventifyInitEventArgs(name) {\n        if (name == \"delaychange\") {\n            return [this._delay];\n        } else {\n            return super.eventifyInitEventArgs(name)\n        }\n    }\n\n\t// overrides\n\tonUpdateStart(arg) {\n\t\t/*\n\t\t\tVector's timestamp always time-shifted (back-dated) by delay\n\n\t\t\tNormal operation is to delay every incoming vector update.\n\t\t\tThis implies returning null to abort further processing at this time,\n\t\t\tand instead trigger a later continuation.\n\n\t\t\tHowever, delay is calculated based on the timestamp of the vector (age), not when the vector is\n\t\t\tprocessed in this method. So, for small small delays the age of the vector could already be\n\t\t\tgreater than delay, indicating that the vector is immediately valid and do not require delayed processing.\n\n\t\t\tThis is particularly true for the first vector, which may be old.\n\n\t\t\tSo we generally check the age to figure out whether to apply the vector immediately or to delay it.\n\t\t*/\n\n\t\tthis._buffer.push(arg);\n\t\t// if timeout for next already defined, nothing to do\n\t\tif (!this._timeout.isSet()) {\n\t\t\tthis.__handleDelayed();\n\t\t}\n\t\treturn;\n\t};\n\n\t__handleDelayed() {\n\t\t// run through buffer and apply vectors that are due\n\t\tlet now = this.clock.now();\n\t\tlet arg, due;\n\t\twhile (this._buffer.length > 0) {\n\t\t\tdue = this._buffer[0].timestamp + this._delay;\n\t\t\tif (now < due) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\targ = this._buffer.shift();\n\t\t\t\t// apply\n\t\t\t\targ.timestamp = due;\n\t\t\t\tthis.__process(arg);\n\t\t\t}\n\t\t}\n\t\t// set new timeout\n\t\tif (this._buffer.length > 0) {\n\t\t\tdue = this._buffer[0].timestamp + this._delay;\n\t\t\tthis._timeout.setTimeout(due);\n\t\t}\n\t};\n\n\tupdate(arg) {\n\t\t// Updates are prohibited on delayed timingobjects\n\t\tthrow new Error (\"update is not legal on delayed (non-live) timingobject\");\n\t};\n\n    get delay() {return this._delay;};\n\n\tset delay(delay) {\n        if (delay != this._delay) {\n            // set delay and emulate new event from timingsrc\n            this._delay = delay;\n            this._timeout.clear();\n            this.__handleDelayed();\n            this.eventifyTrigger(\"delaychange\", delay);\n        }\n    }\n}\n\nexport default DelayConverter;\n\n","/*\n\tCopyright 2015 Norut Northern Research Institute\n\tAuthor : Ingar Mhlum Arntzen\n\n    This file is part of the Timingsrc module.\n\n    Timingsrc is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    Timingsrc is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/*\n\tSCALE CONVERTER\n\n\tScaling by a factor 2 means that values of the timing object (position, velocity and acceleration) are multiplied by two.\n\tFor example, if the timing object represents a media offset in seconds, scaling it to milliseconds implies a scaling factor of 1000.\n\n*/\n\nimport TimingObject from './timingobject.js';\n\n\nclass ScaleConverter extends TimingObject {\n    constructor (timingsrc, factor) {\n\t\tsuper(timingsrc);\n\t\tthis._factor = factor;\n        this.eventifyDefine(\"scalechange\", {init:true});\n\t};\n\n    // extend\n    eventifyInitEventArgs(name) {\n        if (name == \"scalechange\") {\n            return [this._factor];\n        } else {\n            return super.eventifyInitEventArgs(name)\n        }\n    }\n\n\t// overrides\n    onUpdateStart(arg) {\n        if (arg.range != undefined) {\n            arg.range = [arg.range[0]*this._factor, arg.range[1]*this._factor];\n        }\n        if (arg.position != undefined) {\n            arg.position *= this._factor;\n        }\n        if (arg.velocity != undefined) {\n            arg.velocity *= this._factor;\n        }\n        if (arg.acceleration != undefined) {\n            arg.acceleration *= this._factor;\n        }\n        return arg;\n    }\n\n\tupdate(arg) {\n\t\tif (arg.position != undefined) {\n            arg.position /= this._factor;\n        }\n\t\tif (arg.velocity != undefined) {\n            arg.velocity /= this._factor;\n        }\n\t\tif (arg.acceleration != undefined) {\n            arg.acceleration /= this._factor;\n        }\n\t\treturn super.update(arg);\n\t};\n\n    get scale() {return this._factor;};\n\n    set scale(factor) {\n        if (factor != this._factor) {\n            // set scale and emulate new event from timingsrc\n            this._factor = factor;\n            this.__handleEvent({\n                ...this.__get_timingsrc().vector,\n                range: this.__get_timingsrc().range\n            });\n            this.eventifyTrigger(\"scalechange\", factor);\n        }\n    }\n}\nexport default ScaleConverter;\n\n","/*\n\tCopyright 2015 Norut Northern Research Institute\n\tAuthor : Ingar Mhlum Arntzen\n\n\tThis file is part of the Timingsrc module.\n\n\tTimingsrc is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU Lesser General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tTimingsrc is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU Lesser General Public License for more details.\n\n\tYou should have received a copy of the GNU Lesser General Public License\n\talong with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\n\tLOOP CONVERTER\n\n\tThis is a modulo type transformation where the converter will be looping within\n\ta given range. Potentially one could create an associated timing object keeping track of the\n\tloop number.\n*/\n\n\nimport {calculateVector} from '../util/motionutils.js';\nimport TimingObject from './timingobject.js';\n\n\n// ovverride modulo to behave better for negative numbers\nfunction mod(n, m) {\n\treturn ((n % m) + m) % m;\n};\n\nfunction transform(x, range) {\n\tlet skew = range[0];\n\tlet length = range[1] - range[0];\n\treturn skew + mod(x-skew, length);\n}\n\n\n/*\n\tLOOP CONVERTER\n*/\n\nclass LoopConverter extends TimingObject {\n\n\tconstructor(timingsrc, range) {\n\t\tsuper(timingsrc, {timeout:true});\n\t\tthis.__range = range;\n\t};\n\n\tupdate(arg) {\n\t\t// range change - only a local operation\n\t\tif (arg.range != undefined) {\n\t\t\t// implement local range update\n\t\t\tlet [low, high] = arg.range;\n\t\t\tif (low >= high) {\n\t\t\t\tthrow new Error(\"illegal range\", arg.range)\n\t\t\t}\n\t\t\tif (low != this.__range[0] || high != this.__range[1]) {\n\t\t\t\tthis.__range = [low, high];\n\t\t\t\tlet vector = this.__get_timingsrc().query();\n\t\t\t\tvector.position = transform(vector.position, this.__range);\n\t\t\t\tthis.__vector = vector;\n\t\t\t\t// trigger vector change\n\t\t\t\tlet _arg = {range: this.__range, ...this.__vector, live:true};\n\t\t\t\tthis.__dispatchEvents(_arg, true, true);\n\t\t\t}\n\t\t\tdelete arg.range;\n\t\t}\n\t\t// vector change\n\t\tif (arg.position != undefined) {\n\t\t\t// inverse transformation of position, from looper\n\t\t\t// coordinates to timingsrc coordinates\n\t\t\t// preserve relative position diff\n\t\t\tlet now = this.clock.now();\n\t\t\tlet now_vector = calculateVector(this.vector, now);\n\t\t\tlet diff = now_vector.position - arg.position;\n\t\t\tlet now_vector_src = calculateVector(this.__get_timingsrc().vector, now);\n\t\t\targ.position = now_vector_src.position - diff;\n\t\t}\n\t\treturn super.update(arg);\n\t};\n\n\t// overrides\n\tonRangeViolation(vector) {\n\t\t// vector is moving\n\t\tif (vector.position <= this.__range[0]) {\n\t\t\tvector.position = this.__range[1];\n\t\t} else if (this.__range[1] <= vector.position) {\n\t\t\tvector.position = this.__range[0];\n\t\t}\n\t\treturn vector;\n\t};\n\n\t// overrides\n\tonUpdateStart(arg) {\n        if (arg.range != undefined) {\n            // ignore range change from timingsrc\n            // instead, insist that this._range is correct\n            arg.range = this.__range;\n        }\n        if (arg.position != undefined) {\n        \t// vector change\n        \targ.position = transform(arg.position, this.__range);\n        }\n        return arg;\n\t};\n\n}\nexport default LoopConverter;\n\n","/*\n\tCopyright 2015 Norut Northern Research Institute\n\tAuthor : Ingar Mhlum Arntzen\n\n\tThis file is part of the Timingsrc module.\n\n\tTimingsrc is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU Lesser General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tTimingsrc is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU Lesser General Public License for more details.\n\n\tYou should have received a copy of the GNU Lesser General Public License\n\talong with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/*\n\n\tRANGE CONVERTER\n\n\tThe converter enforce a range on position.\n\n\tIt only has effect if given range is a restriction on the range of the timingsrc.\n\tRange converter will pause on range endpoints if timingsrc leaves the range.\n\tRange converters will continue mirroring timingsrc once it comes into the range.\n*/\n\n\nimport {RangeState, correctRangeState, checkRange} from '../util/motionutils.js';\nimport TimingObject from './timingobject.js';\n\n\nfunction state() {\n\tvar _state = RangeState.INIT;\n\tvar _range = null;\n\tvar is_special_state_change = function (old_state, new_state) {\n\t\t// only state changes between INSIDE and OUTSIDE* are special state changes.\n\t\tif (old_state === RangeState.OUTSIDE_HIGH && new_state === RangeState.OUTSIDE_LOW) return false;\n\t\tif (old_state === RangeState.OUTSIDE_LOW && new_state === RangeState.OUTSIDE_HIGH) return false;\n\t\tif (old_state === RangeState.INIT) return false;\n\t\treturn true;\n\t}\n\tvar get = function () {return _state;};\n\tvar set = function (new_state, new_range) {\n\n\t\tvar absolute = false; // absolute change\n\t\tvar special = false;  // special change\n\n\t\t// check absolute change\n\t\tif (new_state !== _state || new_range !== _range) {\n\t\t\tabsolute = true;\n\t\t}\n\t\t// check special change\n\t\tif (new_state !== _state) {\n\t\t\tspecial = is_special_state_change(_state, new_state);\n\t\t}\n\t\t// range change\n\t\tif (new_range !== _range) {\n\t\t\t_range = new_range;\n\t\t}\n\t\t// state change\n\t\tif (new_state !== _state) {\n\t\t\t_state = new_state;\n\t\t}\n\t\treturn {special:special, absolute:absolute};\n\n\t}\n\treturn {get: get, set:set};\n};\n\n\n/*\n\tRange converter allows a new (smaller) range to be specified.\n\n\t- ignores the range of its timingsrc\n\t- vector change from timingsrc\n\t  - outside own range - drop - set timeout to inside\n\t  - inside own range - normal processing\n\t- extra vector changes (compared to timingsrc)\n\t\t- enter inside\n\t\t- range violation own range\n\t- range updated locally\n\n*/\n\nclass RangeConverter extends TimingObject {\n\n\tconstructor (timingObject, range) {\n\t\tsuper(timingObject, {timeout:true});\n\t\tthis.__state = state();\n\t\tthis.__range = range;\n\t};\n\n\n\tupdate(arg) {\n\t\tthrow Error(\"Not Implemented!\");\n\t\t/*\n\t\t\trange change - only a local operation\n\n\t\t\t\t- need to trigger local processing of new range,\n\t\t\t\tso that range is changed and events triggered\n\t\t\t\t- also need to trigger a reevaluation of\n\t\t\t\tvector from timingsrc vector, for instance, if\n\t\t\t\trange grows while timingsrc is outside, the\n\t\t\t\tposition of the vector needs to change\n\t\t\t\t- cannot do both these things via emulation\n\t\t\t\tof timingsrc event - because rangeconverter\n\t\t\t\tis supposed to ignore range change from timingsrc\n\t\t\t\t- could do both locally, but this would effectively\n\t\t\t\trequire reimplementation of logic in __process\n\t\t\t\t- in addition, this could be a request to update\n\t\t\t\tboth range and vector at the same time, in which case\n\t\t\t\tit would be good to do them both at the same time\n\n\t\t\t- possible solution - somehow let range converter\n\t\t\t  discriminate range changes based on origin?\n\n\t\t*/\n\t\tif (arg.range != undefined) {\n\n\t\t\t// local processing of range change\n\t\t\t// to trigger range change event\n\t\t\tlet _arg = {range: arg.range, ...this.__get_timingsrc().vector, live:true};\n\t\t\tthis.__process(_arg);\n\t\t\t// avoid that range change affects timingsrc\n\t\t\tdelete arg.range;\n\n\t\t}\n\t\treturn super.update(arg);\n\t};\n\n\n\n\t// overrides\n\tonUpdateStart(arg) {\n        if (arg.range != undefined) {\n        \t// ignore range change from timingsrc\n        \t// delete causes update to be dropped\n            delete arg.range;\n        }\n        if (arg.position != undefined) {\n        \t// vector change from timingsrc\n        \tlet {position, velocity, acceleration, timestamp} = arg;\n        \tlet vector = {position, velocity, acceleration, timestamp};\n        \tvector = this.onVectorChange(vector);\n        \tif (vector == undefined) {\n        \t\t// drop because motion is outside\n\t\t\t\t// create new timeout for entering inside\n\t\t\t\tthis.__renewTimeout(this.__get_timingsrc().vector, this.__range);\n\t\t\t\treturn;\n        \t} else {\n        \t\t// regular\n        \t\targ.position = vector.position;\n        \t\targ.velocity = vector.velocity;\n        \t\targ.acceleration = vector.acceleration;\n        \t\targ.timestamp = vector.timestamp;\n        \t}\n        }\n        return arg;\n\t};\n\n\n\tonVectorChange(vector) {\n\t\tvar new_state = correctRangeState(vector, this.__range);\n\t\tvar state_changed = this.__state.set(new_state, this.__range);\n\t\tif (state_changed.special) {\n\t\t\t// state transition between INSIDE and OUTSIDE\n\t\t\tif (this.__state.get() === RangeState.INSIDE) {\n\t\t\t\t// OUTSIDE -> INSIDE, generate fake start event\n\t\t\t\t// vector delivered by timeout\n\t\t\t\t// forward event unchanged\n\t\t\t} else {\n\t\t\t\t// INSIDE -> OUTSIDE, generate fake stop event\n\t\t\t\tvector = checkRange(vector, this.__range);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// no state transition between INSIDE and OUTSIDE\n\t\t\tif (this.__state.get() === RangeState.INSIDE) {\n\t\t\t\t// stay inside or first event inside\n\t\t\t\t// forward event unchanged\n\t\t\t} else {\n\t\t\t\t// stay outside or first event outside\n\t\t\t\t// forward if\n\t\t\t\t// - first event outside\n\t\t\t\t// - skip from outside-high to outside-low\n\t\t\t\t// - skip from outside-low to outside-high\n\t\t\t\t// - range change\n\t\t\t\t// else drop\n\t\t\t\t// - outside-high to outside-high (no range change)\n\t\t\t\t// - outside-low to outside-low (no range change)\n\t\t\t\tif (state_changed.absolute) {\n\t\t\t\t\tvector = checkRange(vector, this.__range);\n\t\t\t\t} else {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vector;\n\t};\n}\n\nexport default RangeConverter;\n\n","/*\n\tCopyright 2015 Norut Northern Research Institute\n\tAuthor : Ingar Mhlum Arntzen\n\n    This file is part of the Timingsrc module.\n\n    Timingsrc is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    Timingsrc is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/*\n\tTIMESHIFT CONVERTER\n\n\tTimeshift Converter timeshifts a timing object by timeoffset.\n\tPositive timeoffset means that the converter will run ahead of the source timing object.\n\tNegative timeoffset means that the converter will run behind the source timing object.\n\n\tUpdates affect the converter immediately.\n    This means that update vector must be re-calculated\n\tto the value it would have at time-shifted time.\n    Timestamps are not time-shifted, since the motion is still live.\n\tFor instance, (0, 1, ts) becomes (0+(1*timeshift), 1, ts)\n\n\tHowever, this transformation may cause range violation\n\t\t- this happens only when timing object is moving.\n\t\t- implementation requires range converter logic\n\n\t- range is infinite\n*/\n\nimport TimingObject from './timingobject.js';\nimport {calculateVector} from '../util/motionutils.js';\n\n\nclass TimeshiftConverter extends TimingObject {\n\n    constructor (timingsrc, offset) {\n\t\tsuper(timingsrc);\n\t\tthis._offset = offset;\n        this.eventifyDefine(\"offsetchange\", {init:true});\n\t};\n\n    // extend\n    eventifyInitEventArgs(name) {\n        if (name == \"offsetchange\") {\n            return [this._offset];\n        } else {\n            return super.eventifyInitEventArgs(name)\n        }\n    }\n\n    // overrides\n    onUpdateStart(arg) {\n        if (arg.range != undefined) {\n            arg.range = [-Infinity, Infinity];\n        }\n        if (arg.position != undefined) {\n            // calculate timeshifted vector\n            let ts = arg.timestamp;\n            let new_vector = calculateVector(arg, ts + this._offset);\n            arg.position = new_vector.position;\n            arg.velocity = new_vector.velocity;\n            arg.acceleration = new_vector.acceleration;\n            arg.timestamp = ts;\n        }\n        return arg;\n    };\n\n    get offset() {return this._offset;};\n\n    set offset(offset) {\n        if (offset != this._offset) {\n            // set offset and emulate new event from timingsrc\n            this._offset = offset;\n            this.__handleEvent({\n                ...this.__get_timingsrc().vector,\n                range: this.__get_timingsrc().range\n            });\n            this.eventifyTrigger(\"offsetchange\", offset);\n        }\n    }\n\n}\n\nexport default TimeshiftConverter;\n","/*\n\tCopyright 2020\n\tAuthor : Ingar Mhlum Arntzen\n\n\tThis file is part of the Timingsrc module.\n\n\tTimingsrc is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU Lesser General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tTimingsrc is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU Lesser General Public License for more details.\n\n\tYou should have received a copy of the GNU Lesser General Public License\n\talong with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/**\n * Sampler for Timing Object\n * \n * - samples timing object position and emits a change event at certain frequency\n * - does not emit any events when timing object is paused\n * - options\n *      - period (between samples) in ms\n *      - frequency (sample frequency) in hz\n *      if both given - period takes precedence\n *      if none given - default period = 200 ms \n * \n *  TODO\n        - set refresh frequency to be sensitive\n            to velocity - adapted to a fixed rate\n            change in percent\n            calculate percent velocity\n            rate change in percent per second\n\n * \n * \n */\n\nimport eventify from '../util/eventify.js';\n\nconst DEFAULT_PERIOD = 200;\n\nclass TimingSampler {\n\n    constructor (timingObject, options = {}) {\n        this._to = timingObject;\n        // timeout id\n        this._tid;\n        // period\n        let {period, frequency} = options;\n        this._period = DEFAULT_PERIOD;\n        if (period != undefined) {\n            this._period = period;\n        } else if (frequency != undefined) {\n            this._period = 1.0/frequency;\n        }        \n        // Events\n        eventify.eventifyInstance(this);\n\n        this.eventifyDefine(\"change\", {init:true});\n        // Handle timing object change event\n        this._sub = this._to.on(\"change\", this._onChange.bind(this));\n    }\n\n    /*\n        Eventify: immediate events\n    */\n    eventifyInitEventArgs(name) {\n        if (name == \"change\" && this._to.isReady()) {\n            return [this._to.pos];\n        }\n    }\n\n    /**\n     * Start/stop sampling\n     */\n    _onChange() {\n        let v = this._to.query();\n        let moving = (v.velocity != 0.0 || v.acceleration != 0.0);\n        // start or stop sampling\n        if (moving && this._tid == undefined) {\n            this._tid = setInterval(function(){\n                this._onSample();\n            }.bind(this), this._period);\n        }\n        if (!moving && this._tid != undefined) {\n            clearTimeout(this._tid);\n            this._tid = undefined;\n        }\n        this._onSample(v.position);\n    }\n\n    /**\n     * Sample timing object\n     */\n    _onSample(position) {\n        position = (position != undefined) ? position : this._to.pos;\n        this.eventifyTrigger(\"change\", position);\n    }\n   \n    /**\n     * Terminate sampler\n     */\n    clear() {\n        // stop sampling\n        if (this._tid) {\n            clearTimeout(this._tid);\n            this._tid = undefined;\n        }\n        // disconnect handler\n        this._to.off(this._sub);\n    }\n}\n\neventify.eventifyPrototype(TimingSampler.prototype);\n\nexport default TimingSampler;","\n\n\nimport Timeout from '../util/timeout.js';\nimport * as motionutils from '../util/motionutils.js';\n\n/*\n    modify modulo operation\n*/\nfunction mod(n,m) {\n    return ((n % m) + m) % m;   \n}\n\n/*\n    divide n by m, \n    find q (integer) and r such that  \n    n = q*m + r \n*/\nfunction divmod(n, m) {\n    let q = Math.floor(n/m);\n    let r = mod(n, m);\n    return [q,r];\n}\n\n/**\n *  point n == offset + q*stride + r\n    - given stride, offset\n    represent point as [q, r]\n */\n\nfunction float2point(n, stride, offset) {\n    return divmod(n-offset, stride);\n}\n\nfunction point2float(p, stride, offset) {\n    let [q, r] = p;\n    return offset + q*stride + r;\n}\n\n\n/*\n    Given stride and offset, calculate nearest\n    waypoints before and after given position.\n    If position is exact match with waypoint,\n    return [true, before, after]\n*/\nfunction stride_points(position, stride, offset) {\n    let [q, r] = float2point(position, stride, offset);\n    let after = [q+1, 0];\n    let before = (r == 0) ? [q-1, 0]: [q, 0];\n    before = point2float(before, stride, offset);\n    after = point2float(after, stride, offset);\n    return [(r==0), before, after];\n};\n\n\n\n/*\n    \n    Position callback\n\n    - callback whenever the timing object position is x, \n      where (x - offset) % stride === 0\n\n    - analogy to setInterval - except callbacks are in position space, not\n      in time space\n\n    options : {\n        stride - default 1\n        offset - default 0\n    }\n\n    NOTE: pausing on x and later resuming from x triggers callback in both cases \n\n*/\n\nclass PositionCallback {\n\n    constructor (timingObject, callback, options={}) {\n        this._to = timingObject;\n        let {stride=1, offset=0} = options;\n        this._offset = offset;\n        this._stride = stride;\n        this._callback = callback;\n        this._timeout = new Timeout(this._to, this._handleTimeout.bind(this));\n\n        // timing object timingsrc event\n        this._to.on(\"timingsrc\", this._onChange.bind(this));\n    }\n\n    _onChange(eArg, eInfo) {\n        let pos = (eArg.live) ? eArg.position : this._to.pos;                \n        this._renewTimeout(pos);\n    }\n\n    _calculateTimeout(before, after) {\n        let vector = this._to.query();\n        let [delta, pos] = motionutils.calculateDelta(vector, [before, after]);\n        if (delta == undefined) {            \n            return;\n        } \n        // check range violation\n        let [rLow, rHigh] = this._to.range;\n        if (pos < rLow || rHigh < pos ) {\n            return [undefined, undefined];\n        }\n        return [vector.timestamp + delta, pos];   \n    }\n\n    _renewTimeout(pos) {\n        this._timeout.clear();\n        // find candidate points - before and after\n        let [match, before, after]  = stride_points(pos,\n                                                    this._stride, \n                                                    this._offset);\n        // callback\n        if (match) {\n            this._callback(pos);\n        }\n        // calculate timeout to next\n        let res = this._calculateTimeout(before, after);\n        if (res == undefined) {\n            return;\n        }\n        // set timeout\n        let ts = res[0];\n        this._timeout.setTimeout(ts, res);\n    }\n    \n    _handleTimeout(now, arg) {\n        let pos = arg[1];\n        this._renewTimeout(pos);\n    }\n}\n\n\nexport default PositionCallback;","/*\n    Copyright 2020\n    Author : Ingar Arntzen\n\n    This file is part of the Timingsrc module.\n\n    Timingsrc is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    Timingsrc is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport ObservableMap from '../util/observablemap.js';\nimport Interval from '../util/interval.js';\n\n/**\n *  Extends ObservableMap\n * \n *  with logic specific to collections of cues.\n */\n\nclass CueCollection extends ObservableMap {\n\n    static cmpLow(cue_a, cue_b) {\n        return Interval.cmpLow(cue_a.interval, cue_b.interval);\n    }\n\n    static cmpHigh(cue_a, cue_b) {\n        return Interval.cmpHigh(cue_a.interval, cue_b.interval);\n    }\n\n    // extend sortOrder to accept order as string\n    sortOrder(options={}) {\n        let order = options.order || super.sortOrder(options);\n        if (order == \"low\") {\n            return CueCollection.cmpLow;\n        } else if (order == \"high\") {\n            return CueCollection.cmpHigh;\n        } else {\n            if (typeof order != \"function\") {\n                return;\n            }\n        }\n        return order;\n    }\n\n    // add cues method\n    cues (options = {}) {\n        let cues = this.sortValues(this.values(), options);\n        // ensure array\n        return (Array.isArray(cues)) ? cues : [...cues];\n    }\n}\n\n// module definition\nexport default CueCollection;","/*\n    Copyright 2020\n    Author : Ingar Arntzen\n\n    This file is part of the Timingsrc module.\n\n    Timingsrc is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    Timingsrc is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\nimport * as utils from '../util/utils.js';\nimport endpoint from '../util/endpoint.js';\nimport Interval from '../util/interval.js';\nimport BinarySearch from '../util/binarysearch.js';\nimport CueCollection from './cuecollection.js';\n\nconst Relation = Interval.Relation;\n\n/*\n    UTILITY\n*/\n\n\n/*\n    Add cue to array\n    - does not add if cue already exists\n    - returns array length\n*/\nvar addCueToArray = function (arr, cue) {\n    // cue equality defined by key property\n    if (arr.length == 0) {\n        arr.push(cue);\n    } else {\n        let idx = arr.findIndex(function (_cue) {\n            return _cue.key == cue.key;\n        });\n        if (idx == -1) {\n            arr.push(cue);\n        }\n    }\n    return arr.length;\n};\n\n/*\n    Remove cue from array\n    - noop if cue does not exist\n    - returns array empty\n*/\nvar removeCueFromArray = function (arr, cue) {\n    // cue equality defined by key property\n    if (arr.length == 1) {\n        if (arr[0].key == cue.key) {\n            arr.shift();\n        }\n        return arr.length == 0;\n    }\n    else if (arr.length == 0) {\n        return true;\n    } else {\n        let idx = arr.findIndex(function (_cue) {\n            return _cue.key == cue.key;\n        });\n        if (idx > -1) {\n            arr.splice(idx, 1);\n        }\n        return arr.length == 0;\n    }\n};\n\n/*\n    Setup ID's for cue buckets.\n*/\nconst CueBucketIds = [0, 10, 100, 1000, 10000, 100000, Infinity];\nvar getCueBucketId = function (length) {\n    for (let i=0; i<CueBucketIds.length; i++) {\n        if (length <= CueBucketIds[i]) {\n            return CueBucketIds[i];\n        }\n    }\n};\n\n\n/*\n    Delta\n\n    Used to represent statechanges in batchMap,\n    for intervals and data.\n*/\nconst Delta = Object.freeze({\n    NOOP: 0,\n    INSERT: 1,\n    REPLACE: 2,\n    DELETE: 3\n});\n\n/*\n    make a shallow copy of a cue\n*/\nfunction cue_copy(cue) {\n    if (cue == undefined) {\n        return;\n    }\n    return {\n        key: cue.key,\n        interval: cue.interval,\n        data: cue.data\n    };\n}\n\n/*\n    Characterize the transition from cue_a to cue_b\n    in terms of delta values for interval and data\n\n    For instance, interval has\n    - INSERT: value not in a but in b\n    - DELETE: value in a but not in b\n    - REPLACE: value in a and in be and not equal\n    - NOOP: either remains undefined or remains equal\n\n    optional equals function for data comparison\n    otherwise simple object equality (==) is used\n*/\nfunction cue_delta(cue_a, cue_b, equals) {\n    let interval_delta, data_delta, eq;\n    // interval delta\n    let a_interval_defined = cue_a != undefined && cue_a.interval != undefined;\n    let b_interval_defined = cue_b != undefined && cue_b.interval != undefined;\n    if (!a_interval_defined && !b_interval_defined) {\n        interval_delta = Delta.NOOP;\n    } else if (!a_interval_defined) {\n        interval_delta = Delta.INSERT;\n    } else if (!b_interval_defined) {\n        interval_delta = Delta.DELETE;\n    } else {\n        // check interval equality\n        eq = cue_a.interval.equals(cue_b.interval);\n        interval_delta = (eq) ? Delta.NOOP : Delta.REPLACE;\n    }\n    // data delta\n    let a_data_defined = cue_a != undefined && cue_a.data != undefined;\n    let b_data_defined = cue_b != undefined && cue_b.data != undefined;\n    if (!a_data_defined && !b_data_defined) {\n        data_delta = Delta.NOOP;\n    } else if (!a_data_defined) {\n        data_delta = Delta.INSERT;\n    } else if (!b_data_defined) {\n        data_delta = Delta.DELETE;\n    } else {\n        // check data equality\n        if (equals) {\n            eq = equals(cue_a.data, cue_b.data);\n        } else {\n            eq = utils.object_equals(cue_a.data, cue_b.data);\n        }\n        data_delta = (eq) ? Delta.NOOP : Delta.REPLACE;\n    }\n    return {interval: interval_delta, data: data_delta};\n}\n\n\n\n/*\n    CUE ORDERING AND SORTING\n*/\n\nfunction cue_cmp_forwards (cue_a, cue_b) {\n    return Interval.cmpLow(cue_a.iterval, cue_b.interval);\n}\n\nfunction cue_cmp_backwards (cue_a, cue_b) {\n    return -1 * Interval.cmpHigh(cue_a.iterval, cue_b.interval);\n}\n\nfunction sort_cues (cues, direction=0) {\n    if (direction >= 0) {\n        cues.sort(cue_cmp_forwards);\n    } else {\n        cuess.sort(cue_cmp_backwards);\n    }\n}\n\n\n/*\n    CueArgBuilder\n\n    AddCue - adds or changes a cue.\n    RemoveCue - removes a cue\n    Submit - submits the cues to the dataset update operation\n    Clear - remove un-submitted cues\n\n*/\n\nclass CueArgBuilder {\n\n    constructor (dataset) {\n        this._cues = [];\n        this._ds = dataset;\n    }\n\n    /*\n        AddCue\n    \n        if both interval and data are undefined\n        this is not interpreted as remove,\n        but as a cue with no interval and a data value set\n        to undefined\n    */\n    addCue(key, interval, data) {\n        let cue = {key:key, data:data};\n        if (interval instanceof Interval) {\n            cue.interval = interval;\n        }\n        this._cues.push(cue);\n        return this;\n    }\n\n    removeCue(key) {\n        this._cues.push({key:key});\n        return this;\n    }\n\n    clear() {\n        this._cues = [];\n        return this;\n    }\n\n    submit(options) {\n        let cues = this._cues;\n        this._cues = [];\n        return this._ds.update(cues, options);\n    }\n}\n\n\n\n/*\n    this implements Dataset, a data collection supporting\n    efficient lookup of cues tied to intervals on the timeline\n\n    - cues may be tied to one or two points on the timeline, this\n      is expressed by an Interval.\n    - cues are indexed both by key and by intervals\n    - the interval index is divided into a set of CueBuckets,\n      based on cue interval length, for efficient lookup\n*/\n\nclass Dataset extends CueCollection {\n\n    static sort_cues = sort_cues;\n    static Delta = Delta;\n    static cue_delta = cue_delta;\n\n    constructor() {\n        super();\n\n        this._map = new Map();\n\n        /*\n            Initialise set of CueBuckets\n            Each CueBucket is responsible for cues of a certain length\n        */\n        this._cueBuckets = new Map();  // CueBucketId -> CueBucket\n        for (let i=0; i<CueBucketIds.length; i++) {\n            let cueBucketId = CueBucketIds[i];\n            this._cueBuckets.set(cueBucketId, new CueBucket(cueBucketId));\n        }\n\n        // Inline update callbacks\n        this._update_callbacks = [];\n    };\n\n    /**\n     * CueCollection (ObservableMap) needs access to map \n     */\n    get datasource () {\n        return this._map;\n    }\n\n    /***************************************************************\n        UPDATE CALLBACKS\n    */\n\n    add_callback (handler) {\n        let handle = {\n            handler: handler\n        }\n        this._update_callbacks.push(handle);\n        return handle;\n    };\n\n\n    del_callback (handle) {\n        let index = this._update_callbacks.indexof(handle);\n        if (index > -1) {\n            this._update_callbacks.splice(index, 1);\n        }\n    };\n\n\n    _notify_callbacks (batchMap, relevanceInterval) {\n        this._update_callbacks.forEach(function(handle) {\n            handle.handler(batchMap, relevanceInterval);\n        });\n    };\n\n    /***************************************************************\n     MAP METHODS\n    */\n\n    set (key, value) {\n        throw new Error(\"not implemented\");\n    }\n\n    delete (key) {\n        throw new Error(\"not implemented\");\n    }\n\n\n    /***************************************************************\n     CUE ARG BUILDER\n    */\n\n    get builder() {\n        return new CueArgBuilder(this);\n    }\n\n    /***************************************************************\n     ADD CUE, REMOVE CUE\n\n        - CONVENIENCE for interactive use\n        - DO NOT USE REPEATEDLY (e.g. in for loop) ANTIPATTERN  \n        - use CUE ARG BUILDER instead to build up cue batch before submit.\n    */\n\n    addCue(key, interval, data) {\n        return this.builder.addCue(key, interval, data).submit();\n    }\n\n    removeCue(key) {\n        return this.builder.removeCue(key).submit();\n    }\n\n\n    /***************************************************************\n        UPDATE\n\n        - insert, replace or delete cues\n\n        update(cues, equals, check)\n\n        <cues> ordered list of cues to be updated\n        <equals> - equality function for data objects\n        <check> - check cue integrity if true\n\n        cue = {\n            key:key,\n            interval: Interval,\n            data: data\n        }\n\n        required\n        - cue.key property is defined and value is != undefined\n        - if cue.interval != undefined, it must be instance of Interval\n\n        EXAMPLES\n\n        // INSERT (no pre-existing cue)\n\n        cue = {key:1, interval: new Interval(3,4), data: {}}\n        // insert cue with only interval\n        cue = {key:1, interval: new Interval(3,4)}\n        // insert cue with only data\n        cue = {key:1, data: {}}\n\n\n        // REPLACE (pre-existing cue)\n        preexisting_cue = {key:1, interval: new Interval(3,4), data: {}}\n\n        cue = {key:1, interval: new Interval(3,5), data: {foo:\"bar\"}}\n        // replace interval, keep data\n        cue = {key:1, interval: new Interval(3,5)}\n        // replace interval, delete data\n        cue = {key:1, interval: new Interval(3,5), data: undefined\n        // replace data, keep interval\n        cue = {key:1, data: {foo:\"bar\"}}\n        // replace data, delete interval\n        cue = {key:1, interval: undefined, data: {foo:\"bar\"}}\n\n        // DELETE (pre-existing)\n        cue = {key:1}\n        // delete interval, keep data\n        cue = {key:1, interval: undefined}\n        // delete data, keep interval\n        cue = {key:1, data: undefined}\n\n\n        Update returns a list of event items - describes the effects of an update.\n            {\n                new: new_cue,\n                old: old_cue,\n                delta: {\n                    interval: Delta,\n                    data: Delta\n                }\n            }\n\n        with independent delta values for interval and data:\n        Delta.NOOP: 0\n        Delta.INSERT: 1\n        Delta.REPLACE: 2\n        Delta.DELETE: 3\n\n        Duplicates\n        - if there are multiple cue operations for the same key,\n          within the same batch of cues,\n          these will be processed in order.\n\n        - The old cue will always be the state of the cue,\n          before the batch started.\n\n        - The returned delta values will be calcultated relative to\n          the cue before the batch started (old).\n\n          This way, external mirroring observers may will be able to\n          replicate the effects of the update operation.\n\n    ***************************************************************/\n\n    update(cues, options) {\n        const batchMap = new Map();\n        let current_cue;\n        let has_interval, has_data;\n        let init = this._map.size == 0;\n        // options\n        options = options || {};\n        // check is false by default\n        if (options.check == undefined) {\n            options.check = false;\n        }\n        // chaining is true by default\n        if (options.chaining == undefined) {\n            options.chaining = true;\n        }\n\n        if (!utils.isIterable(cues)) {\n            cues = [cues];\n        }\n\n        /***********************************************************\n            process all cues\n        ***********************************************************/\n        for (let cue of cues) {\n\n            /*******************************************************\n                check validity of cue argument\n            *******************************************************/\n\n            if (options.check) {\n                if (!(cue) || !cue.hasOwnProperty(\"key\") || cue.key == undefined) {\n                    throw new Error(\"illegal cue\", cue);\n                }\n            }\n            has_interval = cue.hasOwnProperty(\"interval\");\n            has_data = cue.hasOwnProperty(\"data\");\n            if (options.check && has_interval) {\n                if (!cue.interval instanceof Interval) {\n                    throw new Error(\"interval must be Interval\");\n                }\n            }\n\n            /*******************************************************\n                adjust cue so that it correctly represents\n                the new cue to replace the current cue\n                - includeds preservation of values from current cue\n            *******************************************************/\n\n            current_cue = (init) ? undefined : this._map.get(cue.key);\n            if (current_cue == undefined) {\n                // make sure properties are defined\n                if (!has_interval) {\n                    cue.interval = undefined;\n                }\n                if (!has_data) {\n                    cue.data = undefined;\n                }\n            } else if (current_cue != undefined) {\n                if (!has_interval && !has_data) {\n                    // make sure properties are defined\n                    cue.interval = undefined;\n                    cue.data = undefined;\n                } else if (!has_data) {\n                    // REPLACE_INTERVAL, preserve data\n                    cue.data = current_cue.data;\n                } else if (!has_interval) {\n                    // REPLACE_DATA, preserve interval\n                    cue.interval = current_cue.interval;\n                } else {\n                    // REPLACE CUE\n                }\n            }\n\n            /*******************************************************\n                update cue\n                - update _map\n                - update cueBuckets\n                - create batchMap\n            *******************************************************/\n\n            this._update_cue(batchMap, current_cue, cue, options);\n        }\n        // flush all buckets so updates take effect\n        this._call_buckets(\"flush\");\n        if (batchMap.size > 0) {\n\n            /*\n                create events without delta property\n                and accumulate relevance interval for batch\n            */\n            let relevance = {low: Infinity, high: -Infinity};\n\n            // create list of events and remove delta property\n            let items = [...batchMap.values()].map(item => {\n                if (item.new && item.new.interval) {\n                    relevance.low = endpoint.min(relevance.low, item.new.interval.endpointLow);\n                    relevance.high = endpoint.max(relevance.high, item.new.interval.endpointHigh);\n                }\n                if (item.old && item.old.interval) {\n                    relevance.low = endpoint.min(relevance.low, item.old.interval.endpointLow);\n                    relevance.high = endpoint.max(relevance.high, item.old.interval.endpointHigh);\n                }\n                return {key:item.key, new:item.new, old:item.old};\n            });\n            // event notification\n            this._notifyEvents(items);\n\n            // create relevance Interval\n            let relevanceInterval = undefined;\n            if (relevance.low != Infinity) {\n                relevanceInterval = Interval.fromEndpoints(relevance.low, relevance.high);\n            }\n\n            /*\n                notify sequencer last so that change event\n                from the dataset will be applied before change\n                events from sequencers.\n            */\n            this._notify_callbacks(batchMap, relevanceInterval);\n            return items;\n        }\n        return [];\n    };\n\n\n\n    /***************************************************************\n        UPDATE CUE\n\n        update operation for a single cue\n\n        - update _map\n        - generate entry for batchMap\n        - update CueBucket\n    ***************************************************************/\n\n    _update_cue(batchMap, current_cue, cue, options) {\n        let old_cue, new_cue;\n        let item, _item;\n        let oldCueBucket, newCueBucket;\n        let low_changed, high_changed;\n        let remove_needed, add_needed;\n        let equals = options.equals;\n        let chaining = options.chaining;\n\n        if (current_cue === cue) {\n            throw Error(\"illegal cue arg: same object as current cue\");\n        }\n\n        // check for equality\n        let delta = cue_delta(current_cue, cue, equals);\n\n        // (NOOP, NOOP)\n        if (delta.interval == Delta.NOOP && delta.data == Delta.NOOP) {\n            item = {\n                key:cue.key, new:current_cue,\n                old:current_cue, delta: delta\n            }\n            batchMap.set(cue.key, item);\n            return;\n        }\n\n        /***********************************************************\n            update _map and batchMap\n        ***********************************************************/\n\n        if (current_cue == undefined) {\n            // INSERT - add cue object to _map\n            old_cue = undefined;\n            new_cue = cue;\n            this._map.set(cue.key, new_cue);\n        } else if (cue.interval == undefined && cue.data == undefined) {\n            // DELETE - remove cue object from _map\n            old_cue = current_cue;\n            new_cue = undefined;\n            this._map.delete(cue.key);\n        } else {\n            // REPLACE\n            // in-place modification of current cue\n            // copy old cue before modification\n            old_cue = cue_copy(current_cue);\n            new_cue = current_cue;\n            // update current cue in place\n            new_cue.interval = cue.interval;\n            new_cue.data = cue.data;\n        }\n        item = {key:cue.key, new:new_cue, old:old_cue, delta:delta};\n\n        /*\n            if this item has been set earlier in batchMap\n            restore the correct old_cue by getting it from\n            the previous batchMap item\n\n            recalculate delta relative to old_cue\n            - this delta is only for sequencers\n            - continue processing with the original delta defined\n            above, as this is required to correctly change cueBuckets\n            which have already been affected by previous item.\n        */\n        if (chaining) {\n            _item = batchMap.get(cue.key);\n            if (_item != undefined) {\n                item.old = _item.old;\n                item.delta = cue_delta(new_cue, item.old, equals);\n            }\n        }\n\n        batchMap.set(cue.key, item)\n\n        /***********************************************************\n            update cueBuckets\n\n            - use delta.interval to avoid unnessesary changes\n\n            - interval may change in several ways:\n                - low changed\n                - high changed\n                - low and high changed\n            - changed intervals may stay in bucket or change bucket:\n            - changing to/from singular may require special consideration\n              with respect to how many endpoints are being updated\n                - singular -> singular\n                - singular -> regular\n                - regular -> singular\n                - regular -> regular\n            - changes to interval.lowInclude and interval highInclude\n              do not require any changes to CueBuckets, as long\n              as interval.low and interval.high values stay unchanged.\n        ***********************************************************/\n\n        if (delta.interval == Delta.NOOP) {\n            // data changes are reflected in _map changes,\n            // since data changes are made in-place, these\n            // changes will be visible in cues registered in\n            // CueBuckets\n            return;\n        } else if (delta.interval == Delta.INSERT) {\n            remove_needed = false;\n            add_needed = true;\n            low_changed = true;\n            high_changed = true;\n        } else if (delta.interval == Delta.DELETE) {\n            remove_needed = true;\n            add_needed = false;\n            low_changed = true;\n            high_changed = true;\n        } else if (delta.interval == Delta.REPLACE) {\n            remove_needed = true;\n            add_needed = true;\n            low_changed = item.new.interval.low != item.old.interval.low;\n            high_changed = item.new.interval.high != item.old.interval.high;\n        }\n\n        /*\n            old cue and new cue might not belong to the same cue bucket\n        */\n        if (remove_needed){\n            let old_bid = getCueBucketId(item.old.interval.length);\n            oldCueBucket = this._cueBuckets.get(old_bid);\n        }\n        if (add_needed) {\n            let new_bid = getCueBucketId(item.new.interval.length);\n            newCueBucket = this._cueBuckets.get(new_bid);\n        }\n\n        /*\n            if old CueBucket is different from the new cue Buckets\n            both low and high must be moved, even it one was not\n            changed\n        */\n        if (oldCueBucket && newCueBucket) {\n            if (oldCueBucket != newCueBucket) {\n                remove_needed = true;\n                add_needed = true;\n                low_changed = true;\n                high_changed = true;\n            }\n        }\n\n        /*\n            dispatch add and remove operations for interval points\n\n            cues in CueBucket may be removed using a copy of the cue,\n            because remove is by key.\n\n            cues added to CueBucket must be the correct object\n            (current_cue), so that later in-place modifications become\n            reflected in CueBucket.\n            batchMap item.new is the current cue object.\n        */\n\n        // update low point - if changed\n        if (low_changed) {\n            if (remove_needed) {\n                // console.log(\"remove old low\", item.old.interval.low);\n                oldCueBucket.del_endpoint(item.old.interval.low, item.old);\n            }\n            if (add_needed) {\n                // console.log(\"add new low\", item.new.interval.low);\n                newCueBucket.add_endpoint(item.new.interval.low, item.new);\n            }\n        }\n        // update high point - if changed\n        if (high_changed) {\n            if (remove_needed && !item.old.interval.singular) {\n                // console.log(\"remove old high\", item.old.interval.high);\n                oldCueBucket.del_endpoint(item.old.interval.high, item.old);\n            }\n            if (add_needed && !item.new.interval.singular) {\n                // console.log(\"add new high\", item.new.interval.high);\n                newCueBucket.add_endpoint(item.new.interval.high, item.new);\n            }\n        }\n    }\n\n\n    /*\n        INTERNAL FUNCTION\n        execute method across all cue buckets\n        and aggregate results\n    */\n    _call_buckets(method, ...args) {\n        const arrays = [];\n        for (let cueBucket of this._cueBuckets.values()) {\n            let cues = cueBucket[method](...args);\n            if (cues != undefined && cues.length > 0) {\n                arrays.push(cues);\n            }\n        }\n        return utils.array_concat(arrays);\n    };\n\n    /*\n        LOOKUP ENDPOINTS\n\n        returns (endpoint, cue) for all endpoints covered by given interval\n\n        returns:\n            - [{endpoint: endpoint, cue:cue}]\n    */\n\n    lookup_endpoints(interval) {\n        return this._call_buckets(\"lookup_endpoints\", interval);\n    };\n\n\n    /*\n        LOOKUP\n    */\n\n    lookup(interval, mask) {\n        return this._call_buckets(\"lookup\", interval, mask);\n    };\n\n\n    /*\n        REMOVE CUES BY INTERVAL\n    */\n    lookup_delete(interval, mask) {\n        const cues = this._call_buckets(\"lookup_delete\", interval, mask);\n        // remove from _map and make event items\n        const items = [];\n        let cue;\n        for (let i=0; i<cues.length; i++) {\n            cue = cues[i];\n            this._map.delete(cue.key);\n            // check for equality\n            items.push({key:cue.key, new: undefined, old: cue});\n        }\n        // event notification\n        this._notifyEvents(items);\n        return items;\n    };\n\n    /*\n        CLEAR ALL CUES\n    */\n    clear() {\n        // clear cue Buckets\n        this._call_buckets(\"clear\");\n        // clear _map\n        let _map = this._map;\n        this._map = new Map();\n        // create change events for all cues\n        const items = [];\n        for (let cue of _map.values()) {\n            items.push({key: cue.key, new: undefined, old: cue});\n        }\n        // event notification\n        this._notifyEvents(items);\n        return items;\n    };\n\n\n    /*\n        utility\n    */\n    integrity() {\n        const res = this._call_buckets(\"integrity\");\n\n        // sum up cues and points\n        let cues = [];\n        let points = [];\n        for (let bucketInfo of res.values()) {\n            cues.push(bucketInfo.cues);\n            points.push(bucketInfo.points);\n        }\n        cues = [].concat(...cues);\n        points = [].concat(...points);\n        // remove point duplicates if any\n        points = [...new Set(points)];\n\n        if (cues.length != this._map.size) {\n            throw new Error(\"inconsistent cue count _map and aggregate cueBuckets \" + cues-this._map.size);\n        }\n\n        // check that cues are the same\n        for (let cue of cues.values()) {\n            if (!this._map.has(cue.key)) {\n                throw new Error(\"inconsistent cues _map and aggregate cueBuckets\");\n            }\n        }\n\n        return {\n            cues: cues.length,\n            points: points.length\n        };\n    };\n\n}\n\n\n/*\n    CueBucket is a bucket of cues limited to specific length\n*/\n\n\nclass CueBucket {\n\n\n    constructor(maxLength) {\n\n        // max length of cues in this bucket\n        this._maxLength = maxLength;\n\n        /*\n            pointMap maintains the associations between values (points on\n            the timeline) and cues that reference such points. A single point value may be\n            referenced by multiple cues, so one point value maps to a list of cues.\n\n            value -> [cue, ....]\n        */\n        this._pointMap = new Map();\n\n\n        /*\n            pointIndex maintains a sorted list of numbers for efficient lookup.\n            A large volume of insert and remove operations may be problematic\n            with respect to performance, so the implementation seeks to\n            do a single bulk update on this structure, for each batch of cue\n            operations (i.e. each invocations of addCues). In order to do this\n            all cue operations are processed to calculate a single batch\n            of deletes and a single batch of inserts which then will be applied to\n            the pointIndex in one atomic operation.\n\n            [1.2, 3, 4, 8.1, ....]\n        */\n        this._pointIndex = new BinarySearch();\n\n        // bookeeping during batch processing\n        this._created = new Set(); // point\n        this._dirty = new Set(); // point\n\n    };\n\n\n    /*\n\n        ENDPOINT BATCH PROCESSING\n\n        Needs to translate endpoint operations into a minimum set of\n        operations on the pointIndex.\n\n        To do this, we need to record points that are created and\n        points that are removed.\n\n        The total difference that the batch of cue operations\n        amounts to is expressed as one list of values to be\n        deleted, and and one list of values to be inserted.\n        The update operation of the pointIndex will process both\n        in one atomic operation.\n\n        On flush both the pointMap and the pointIndex will be brought\n        up to speed\n\n        created and dirty are used for bookeeping during\n        processing of a cue batch. They are needed to\n        create the correct diff operation to be applied on pointIndex.\n\n        created : includes values that were not in pointMap\n        before current batch was processed\n\n        dirty : includes values that were in pointMap\n        before current batch was processed, and that\n        have been become empty at least at one point during cue\n        processing.\n\n        created and dirty are used as temporary alternatives to pointMap.\n        after the cue processing, pointmap will updated based on the\n        contents of these two.\n\n        process buffers operations for pointMap and index so that\n        all operations may be applied in one batch. This happens in flush\n    */\n\n    add_endpoint(point, cue) {\n        let init = (this._pointMap.size == 0);\n        let cues = (init) ? undefined : this._pointMap.get(point);\n        if (cues == undefined) {\n            this._pointMap.set(point, [cue]);\n            this._created.add(point);\n        } else {\n            cues.push(cue);\n            //addCueToArray(cues, cue);\n        }\n    }\n\n    del_endpoint(point, cue) {\n        let init = (this._pointMap.size == 0);\n        let cues = (init) ? undefined : this._pointMap.get(point);\n        if (cues != undefined) {\n            let empty = removeCueFromArray(cues, cue);\n            if (empty) {\n                this._dirty.add(point);\n            }\n        }\n    };\n\n    /*\n        Batch processing is completed\n        Commit changes to pointIndex and pointMap.\n\n        pointMap\n        - update with contents of created\n\n        pointIndex\n        - points to delete - dirty and empty\n        - points to insert - created and non-empty\n\n        it is possible that a cue ends up in both created and dirty\n\n    */\n    flush() {\n        if (this._created.size == 0 && this._dirty.size == 0) {\n            return;\n        }\n\n        // update pointIndex\n        let to_remove = [];\n        let to_insert = [];\n        for (let point of this._created.values()) {\n            let cues = this._pointMap.get(point);\n            if (cues.length > 0) {\n                to_insert.push(point);\n            } else {\n                this._pointMap.delete(point);\n            }\n        }\n        for (let point of this._dirty.values()) {\n            let cues = this._pointMap.get(point);\n            if (cues == undefined) {\n                // point already deleted from created set - ignore\n                continue;\n            }\n            if (cues.length == 0) {\n                to_remove.push(point);\n                this._pointMap.delete(point);\n            }\n        }\n        this._pointIndex.update(to_remove, to_insert);\n        // cleanup\n        this._created.clear();\n        this._dirty.clear();\n    };\n\n\n    /*\n        LOOKUP_ENDPOINTS\n\n        returns all (endpoint, cue) pairs where\n            - endpoint is a cue endpoint (cue.endpointLow or cue.endpointHigh)\n            - endpoint is INSIDE search interval\n            - [{endpoint:endpoint, cue: cue}]\n\n        - a given endpoint may appear multiple times in the result,\n          as multiple cues may be tied to the same endpoint\n        - a given cue may appear two times in the result, if\n          both cue.endpointLow and cue.endpointHigh are both INSIDE interval\n        - a singular cue will appear only once\n        - ordering: no specific order is guaranteed\n          - results are concatenated from multiple CueBuckets\n          - internally in a single CueBucket\n            - no defined order for cues tied to the same endpoint\n          - the natural order is endpoint order\n            - but this can be added on the outside if needed\n            - no order is defined if two cues have exactly the\n              same endpoint\n\n    */\n\n    lookup_endpoints(interval) {\n        if (this._pointMap.size == 0) {\n            return [];\n        }\n        const broader_interval = new Interval(interval.low, interval.high, true, true);\n        const points = this._pointIndex.lookup(broader_interval);\n        const result = [];\n        const len = points.length;\n        let point, _endpoint;\n        for (let i=0; i<len; i++) {\n            point = points[i];\n            this._pointMap.get(point)\n                .forEach(function (cue) {\n                    /*\n                        figure out if point is endpoint low or high\n                        include cue if the endpoint is inside search interval\n                    */\n                    if (point == cue.interval.low) {\n                        _endpoint = cue.interval.endpointLow;\n                    } else if (point == cue.interval.high) {\n                        _endpoint = cue.interval.endpointHigh;\n                    } else {\n                        console.log(point)\n                        console.log(cue)\n                        throw new Error(\"fatal: point cue mismatch\");\n                    }\n                    if (interval.covers_endpoint(_endpoint)) {\n                        result.push({endpoint:_endpoint, cue:cue});\n                    }\n                });\n        }\n        return result;\n    }\n\n\n    /*\n        _LOOKUP CUES\n\n        Internal function, used by LOOKUP.\n\n        Return list of cues\n        - all cues with at least one endpoint value v,\n          where interval.low <= v <= interval.high\n        - no duplicates\n\n        Note - some cues may be outside the search interval\n        e.g. if the search interval is [.., 4) then\n        (4, ...] will be returned, even if this strictly\n        is OUTSIDE_RIGHT the search interval.\n        This is necessary in lookup for correct calculation of covers\n        from left_interval.\n    */\n\n    _lookup_cues(interval) {\n        if (this._pointMap.size == 0) {\n            return [];\n        }\n        const broader_interval = new Interval(interval.low, interval.high, true, true);\n        const points = this._pointIndex.lookup(broader_interval);\n        const len = points.length;\n        const cueSet = new Set();\n        const result = [];\n        let low_inside, high_inside;\n        for (let i=0; i<len; i++) {\n            this._pointMap.get(points[i])\n                .forEach(function(cue) {\n                    // avoid duplicates\n                    if (cueSet.has(cue.key)) {\n                        return;\n                    } else {\n                        cueSet.add(cue.key);\n                    }\n                    result.push(cue);\n                });\n        }\n        return result;\n    }\n\n\n\n    /*\n        LOOKUP\n\n        Strategy split task into two subtasks,\n\n        1) find cues [OVERLAP_LEFT, COVERED, EQUALS, OVERLAP_RIGHT]\n        2) find cues [COVERS]\n\n        // mode order\n        Relation.OVERLAP_LEFT,\n        Relation.COVERED,\n        Relation.EQUALS,\n        Relation.COVERS,\n        Relation.OVERLAP_RIGHT\n    */\n\n\n    lookup(interval, mask=Interval.Match.COVERS) {\n\n        if (this._pointMap.size == 0) {\n            return [];\n        }\n\n        let cues = [];\n\n        // ignore illegal values\n        mask &= Interval.Match.COVERS;\n\n        // special case only [EQUALS]\n        if (mask == Relation.EQUALS) {\n            return this._pointMap.get(interval.low).filter(function(cue) {\n                return cue.interval.match(interval, Relation.EQUALS);\n            });\n        }\n\n        // handle match with the basic lookup mask first\n        // [OVERLAP_LEFT, COVERED, EQUALS, OVERLAP_RIGHT]\n        let _mask = mask & Interval.Match.OVERLAP;\n        if (_mask) {\n            // keep cues which match lookup part of basic mask,\n            cues = this._lookup_cues(interval)\n                .filter(function(cue){\n                    return cue.interval.match(interval, _mask);\n                });\n        }\n\n        /*\n            intervals in this CueBucket are limited by maxLength\n            if interval.length is larger than maxLength, no cue\n            in this CueBucket can cover interval\n        */\n        if (interval.length > this._maxLength) {\n            return cues;\n        }\n\n        /*\n            handle match with COVERS separately\n\n            search left of search interval for cues\n            that covers the search interval\n            search left is limited by CueBucket maxlength\n            left_interval: [interval.high-maxLength, interval.low]\n\n            it would be possible to search right too, but we\n            have to choose one.\n        */\n        if (mask & Relation.COVERS) {\n\n\n            let low = interval.high - this._maxLength;\n            let high = interval.low;\n            // protect against float rounding effects creating\n            // high < low by a very small margin\n            [low, high] = [Math.min(low, high), Math.max(low, high)];\n            let left_interval = new Interval(low, high, true, true);\n            this._lookup_cues(left_interval)\n                .forEach(function(cue){\n                    if (cue.interval.match(interval, Relation.COVERS)) {\n                        cues.push(cue);\n                    }\n                });\n        }\n\n        return cues;\n    }\n\n\n    /*\n        REMOVE CUES\n    */\n    lookup_delete(interval, mask) {\n        /*\n            update pointMap\n            - remove all cues from pointMap\n            - remove empty entries in pointMap\n            - record points that became empty, as these need to be deleted in pointIndex\n            - separate into two bucketes, inside and outside\n        */\n        const cues = this.lookup(interval, mask);\n        const to_remove = [];\n        let cue, point, points;\n        for (let i=0; i<cues.length; i++) {\n            cue = cues[i];\n            // points of cue\n            if (cue.interval.singular) {\n                points = [cue.interval.low];\n            } else {\n                points = [cue.interval.low, cue.interval.high];\n            }\n            for (let j=0; j<points.length; j++) {\n                point = points[j];\n                // remove cue from pointMap\n                // delete pointMap entry only if empty\n                let empty = removeCueFromArray(this._pointMap.get(point), cue);\n                if (empty) {\n                    this._pointMap.delete(point);\n                    to_remove.push(point);\n                }\n            }\n        }\n\n        /*\n            update pointIndex\n\n            - remove all points within pointIndex\n            - exploit locality, the operation is limited to a segment of the index, so\n              the basic idea is to take out a copy of segment (slice), do modifications, and then reinsert (splice)\n            - the segment to modify is limited by [interval.low - maxLength, interval.high + maxLenght] as this will cover\n              both cues inside, partial and overlapping.\n\n            # Possible - optimization\n            alternative approach using regular update could be more efficient for very samll batches\n            this._pointIndex.update(to_remove, []);\n            it could also be comparable for huge loads (250.000 cues)\n        */\n\n        to_remove.sort(function(a,b){return a-b});\n        this._pointIndex.removeInSlice(to_remove);\n\n        /*\n            alternative solution\n            this._pointIndex.update(to_remove, []);\n        */\n\n        return cues;\n    };\n\n\n    /*\n        Possible optimization. Implement a removecues method that\n        exploits locality by removing an entire slice of pointIndex.\n        - this can safely be done for LookupMethod.OVERLAP and PARTIAL.\n        - however, for LookupMethod.INSIDE, which is likely the most useful\n          only some of the points in pointIndex shall be removed\n          solution could be to remove entire slice, construct a new slice\n          with those points that should not be deleted, and set it back in.\n    */\n    clear() {\n        this._pointMap.clear();\n        this._pointIndex = new BinarySearch();\n        this._created.clear();\n        this._dirty.clear();\n    };\n\n\n    /*\n        Integrity test for cue bucket datastructures\n        pointMap and pointIndex\n    */\n    integrity() {\n\n        if (this._pointMap.size !== this._pointIndex.length) {\n            throw new Error(\"unequal number of points \" + (this._pointMap.size - this._pointIndex.length));\n        }\n\n        // check that the same cues are present in both pointMap and pointIndex\n        const missing = new Set();\n        for (let point of this._pointIndex.values()) {\n            if (!this._pointMap.has(point)){\n                missing.add(point);\n            }\n        }\n        if (missing.size > 0) {\n            throw new Error(\"differences in points \" + [...missing]);\n        }\n\n        // collect all cues\n        let cues = [];\n        for (let _cues of this._pointMap.values()) {\n            for (let cue of _cues.values()) {\n                cues.push(cue);\n            }\n        }\n        // remove duplicates\n        cues = [...new Map(cues.map(function(cue){\n            return [cue.key, cue];\n        })).values()];\n\n        // check all cues\n        for (let cue of cues.values()) {\n            if (cue.interval.length > this._maxLength) {\n                throw new Error(\"cue interval violates maxLength \",  cue);\n            }\n            let points;\n            if (cue.singular) {\n                points = [cue.interval.low];\n            } else {\n                points = [cue.interval.low, cue.interval.high];\n            }\n            for (let point of points.values()) {\n                if (!this._pointIndex.has(point)) {\n                    throw new Error(\"point from pointMap cue not found in pointIndex \", point);\n                }\n            }\n        }\n\n        return [{\n            maxLength: this._maxLength,\n            points: [...this._pointMap.keys()],\n            cues: cues\n        }];\n    };\n}\n\n// module definition\nexport default Dataset;\n","/*\n    Copyright 2020\n    Author : Ingar Arntzen\n\n    This file is part of the Timingsrc module.\n\n    Timingsrc is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    Timingsrc is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport CueCollection from './cuecollection.js';\nimport {array_concat, map_difference} from '../util/utils.js';\nimport Interval from '../util/interval.js';\n\n/*\n    Subset provides read-only access to subset of a source Dataset\n\n    - <options>\n        - <interva>: if defined only include cues that match the interval\n        - <key_filter> : filter by cue key\n            function keep(key) returns boolena\n        - <data_filter> : filter by cue data\n            function keep(data) returns boolean\n        - <data_convert> : change cue data\n            function convert(data) returns data\n            NOTE: filtering occurs BEFORE convert\n            and only impacts the presentation of cues\n            WARNING: it is possible to change the value\n            in such a way that filtering appears incorrect\n\n    This subset implementation is STATELESS\n    It does not manage its own state, only implements a\n    stateless frontend over its source dataset.\n\n*/\n\nclass Subset extends CueCollection {\n\n    constructor(dataset, options={}) {\n        super(options);\n        this._key_filter = options.key_filter;\n        this._data_filter = options.data_filter;\n        this._interval = options.interval;\n        this._data_convert = options.data_convert;\n        this._size = 0;\n\n        // Callbacks\n        this._callbacks = [];\n\n        // Source Dataset\n        this._src_ds = dataset;\n        let cb = this._onDatasetCallback.bind(this)\n        this._src_ds_cb = this._src_ds.add_callback(cb);\n    }\n\n\n    /***************************************************************\n        ACCESSORS\n    ***************************************************************/\n\n    get datasource () {\n        return this._src_ds;\n    }\n\n    get dataset () {\n        return this._src_ds;\n    }\n\n\n    get interval () {\n        return this._interval;\n    }\n\n    set interval (itv) {\n        this._setInterval(itv);\n    }\n\n\n    /***************************************************************\n        EVENT CALLBACKS - FOR SEQUENCERS\n    ***************************************************************/\n\n    add_callback (handler) {\n        let handle = {\n            handler: handler\n        }\n        this._callbacks.push(handle);\n        return handle;\n    };\n\n\n    del_callback (handle) {\n        let index = this._callbacks.indexof(handle);\n        if (index > -1) {\n            this._callbacks.splice(index, 1);\n        }\n    };\n\n\n    _notify_callbacks (batchMap, relevanceInterval) {\n        this._callbacks.forEach(function(handle) {\n            handle.handler(batchMap, relevanceInterval);\n        });\n    };\n\n\n   /***************************************************************\n        FILTER & CONVER\n    ***************************************************************/\n\n    /* \n        Keep cue \n    */\n\n    _cue_keep(cue) {\n        if (cue == undefined) {\n            return false;\n        }\n        // check if cue matches interval\n        if (this._interval) {\n            if (!this._interval.match(cue.interval)) {\n                return false;\n            }\n        }\n        // check key filter\n        if (this._key_filter) {\n            if (!this._key_filter(cue.key)) {\n                return false;\n            }\n        }\n        // check data filter\n        if (this._data_filter) {\n            if (!this._data_filter(cue.data)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     *  Convert cue\n     */\n    _cue_convert(cue) {\n        if (cue != undefined && this._data_convert) {\n            // copy\n            return {\n                key: cue.key,\n                interval: cue.interval,\n                data: this._data_convert(cue.data)\n            }\n        }\n        return cue;\n    }\n\n    /**\n     * Filter (and modify) event items based on key_filter and data_filter\n     */\n\n    _items_filter_convert(items) {\n        let _items = [];\n        for (let item of items) {\n            if (item.new == undefined && item.old == undefined) {\n                continue;\n            }\n            /* \n            use cue filter function to check relevance of both old and new\n            consider change of unrelevant cue into relevant cue.\n            old cue would be non-relevant, new cue would be relevant\n            Since old cue was not part of the subset before, it needs\n            to be removed from the item - effectively turning the change\n            operation into an add operation. \n            */\n            let _old = (this._cue_keep(item.old)) ? item.old : undefined;\n            let _new = (this._cue_keep(item.new)) ? item.new : undefined;\n            if (_old == undefined && _new == undefined) {\n                continue;\n            }\n            // convert\n            _old = this._cue_convert(_old);\n            _new = this._cue_convert(_new);\n            // push\n            _items.push({key:item.key, new: _new, old: _old});\n        }\n        return _items;\n    }\n\n\n    /***************************************************************\n     LOOKUP\n    ***************************************************************/\n\n    _check_interval(interval) {\n        if (this._interval) {\n           // subset interval\n           if (interval) {\n               // lookup interval - find intersection\n               let intersects = Interval.intersect(interval, this._interval);\n               if (intersects.length == 0) {\n                   console.log(`warning - lookup interval ${interval.toString()} outside the subset interval ${this._interval.toString()}`);\n                   return [];\n                } else {\n                    interval = intersects[0];\n                }\n            } else {\n                // no lookup interval - use subset interval   \n                interval = this._interval;\n            }\n        }\n        return interval;\n    }\n\n    /** \n     * lookup cues\n    */\n\n    lookup(interval, mask) {\n        let _interval = this._check_interval(interval);\n        let cues;\n        if (_interval) {\n            cues = this.datasource.lookup(_interval, mask);\n        } else {\n            cues = [...this.datasource.values()];\n        }\n        // filter & convert cues\n        return cues.filter(this._cue_keep, this)\n            .map(this._cue_convert, this);\n    }\n\n    /* \n        lookup endpoints\n        used by sequencers\n    */\n\n    lookup_endpoints(interval) {\n        let _interval = this._check_interval(interval);\n        let items = this.datasource.lookup_endpoints(_interval);\n        // filter and convert\n        return items.filter((item) => {\n            return this._cue_keep(item.cue);\n        }, this).map((item) => {\n            return {endpoint: item.endpoint, cue: this._cue_convert(item.cue)};\n        }, this);\n    }\n\n    /***************************************************************\n     INITIAL STATE\n    ***************************************************************/\n\n    eventifyInitEventArgs(name) {\n        if (name == \"batch\" || name == \"change\") {\n            // find cues\n            let cues = this.lookup();\n            // make event items\n            let items = cues.map((cue) => {\n                return {key:cue.key, new:cue, old:undefined};\n            });\n            // sort\n            this.sortItems(items);\n            return (name == \"batch\") ? [items] : items;\n        }\n    }\n\n    /***************************************************************\n     DATASET CALLBACK\n    ***************************************************************/\n\n    _onDatasetCallback(eventMap, relevanceInterval) {\n        let items = [...eventMap.values()];\n        items = this._items_filter_convert(items);\n        // update size\n        for (let item of items) {\n            if (item.new != undefined && item.old == undefined) {\n                // add\n                this._size += 1;\n            } else if (item.new == undefined && item.old != undefined) {\n                // remove\n                this._size -= 1;\n            }           \n        }        \n        // forward as events\n        super._notifyEvents(items);\n        // forward as callbacks\n        let batchMap = new Map(items.map((item) => {\n            return [item.key, item];\n        }));\n        if (this._interval) {\n            relevanceInterval = Interval.intersect(this._inverval, relevanceInterval);\n        }\n        this._notify_callbacks(batchMap, relevanceInterval);\n    }\n\n\n    /***************************************************************\n        SET INTERVAL\n    ***************************************************************/\n\n    _setInterval (itv) {\n        if (!itv instanceof Interval) {\n            throw new Error(\"must be interval\", itv.toString());\n        }\n        if (!this._interval || !this._interval.equals(itv)) {\n            // current cues (before interval update)\n            let current_cues = this.lookup();\n            // update interval\n            this._interval = itv;\n            // cues (after interval update)\n            let new_cues = this.datasource.lookup(itv);\n            // filter & convert cues\n            new_cues = new_cues\n                .filter(this._cue_keep, this)\n                .map(this._cue_convert, this);\n            // switch to map representation\n            let currentCueMap = new Map([...current_cues].map((cue) => {\n                return [cue.key, cue];\n            }));\n            let newCueMap = new Map([...new_cues].map((cue) => {\n                return [cue.key, cue];\n            }));\n            // exit and enter cues\n            let exitCueMap = map_difference(currentCueMap, newCueMap);\n            let enterCueMap = map_difference(newCueMap, currentCueMap);\n            // make list of event items\n            let exitItems = [...exitCueMap.values()].map((cue) => {\n                return {key: cue.key, new:undefined, old: cue}\n            });\n            let enterItems = [...enterCueMap.values()].map((cue) => {\n                return {key: cue.key, new:cue, old: undefined}\n            });\n            // update size\n            this._size -= exitItems.length;\n            this._size += enterItems.length;            \n            // event notification\n            const items = array_concat([exitItems, enterItems], {copy:false, order:true});\n            this._notifyEvents(items);\n        }\n    }\n\n    /***************************************************************\n     MAP ACCESSORS\n    ***************************************************************/\n\n    get size () {\n        return this._size;\n    }\n\n    has(key) {\n        return (this.get(key) != undefined);\n    };\n\n    get(key) {\n        let cue = super.get(key);\n        if (cue != undefined && this._cue_keep(cue)) {\n            return this._cue_convert(cue);\n        }\n    };\n\n    keys() {\n        return this.values().map((cue => {\n            return cue.key;\n        }));\n    };\n\n    values() {\n        return [...super.values()]\n            .filter((cue) => {\n                return this._cue_keep(cue);\n            }, this)\n            .map((cue) => {\n                return this._cue_convert(cue);\n            }, this);\n    };\n\n    entries() {\n        return this.values().map((cue) => {\n            return [cue.key, cue];\n        });\n    };\n\n\n    /***************************************************************\n     MAP MODIFICATION METHODS\n    ***************************************************************/\n\n    update(cues, options) {\n        throw new Error(\"not implemented\");\n    }\n\n    set (key, value) {\n        throw new Error(\"not implemented\");\n    }\n\n    delete (key) {\n        throw new Error(\"not implemented\");\n    }\n\n    clear (key) {\n        throw new Error(\"not implemented\");\n    }\n\n}\n\n// module definition\nexport default Subset;","/*\n    Copyright 2020\n    Author : Ingar Arntzen\n\n    This file is part of the Timingsrc module.\n\n    Timingsrc is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    Timingsrc is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\nimport endpoint from '../util/endpoint.js';\nimport Interval from '../util/interval.js';\nimport Timeout from '../util/timeout.js';\nimport * as motionutils from '../util/motionutils.js';\n\nconst pft = motionutils.posInterval_from_timeInterval;\n\nfunction queueCmp(a,b) {\n    return endpoint.cmp(a.tsEndpoint, b.tsEndpoint);\n};\n\nclass Schedule {\n\n    // Default lookahead in seconds\n    static LOOKAHEAD = 5\n\n    constructor(dataset, to, options) {\n        // timingobject\n        this.to = to;\n        // current timeout\n        this.timeout = new Timeout(to, this.run.bind(this));\n        // current vector\n        this.vector;\n        // current time interval\n        this.timeInterval;\n        // current position interval\n        this.posInterval;\n        // dataset\n        this.dataset = dataset;\n        // task queue\n        this.queue = [];\n        // callbacks\n        this.callbacks = [];\n        // options\n        options = options || {};\n        options.lookahead = options.lookahead || Schedule.LOOKAHEAD;\n        this.options = options;\n    }\n\n\n    /***************************************************************\n        CALLBACKS\n    ***************************************************************/\n\n    add_callback (handler) {\n        let handle = {\n            handler: handler\n        }\n        this.callbacks.push(handle);\n        return handle;\n    };\n\n    del_callback (handle) {\n        let index = this.callbacks.indexof(handle);\n        if (index > -1) {\n            this.callbacks.splice(index, 1);\n        }\n    };\n\n    _notify_callbacks (...args) {\n        this.callbacks.forEach(function(handle) {\n            handle.handler(...args);\n        });\n    };\n\n    /***************************************************************\n        MOTION CHANGE\n    ***************************************************************/\n\n    /*\n        update schedule with new motion vector\n    */\n    setVector(vector) {\n        let now = vector.timestamp;\n        // clean up current motion\n        let current_vector = this.vector;\n        if (this.vector != undefined) {\n            this.timeout.clear();\n            this.timeInterval = undefined;\n            this.posInterval = undefined;\n            this.queue = [];\n        }\n        // update vector\n        this.vector = vector;\n        // start scheduler if moving\n        if (motionutils.isMoving(this.vector)) {\n            this.run(now);\n        }\n    }\n\n\n    /***************************************************************\n        TASK QUEUE\n    ***************************************************************/\n\n    /*\n        push eventItem onto queue\n    */\n    push(eventItems) {\n        eventItems.forEach(function(item) {\n            if (this.timeInterval.covers_endpoint(item.tsEndpoint)) {\n                this.queue.push(item);\n            }\n        }, this);\n        // maintain ordering\n        this.queue.sort(queueCmp);\n    };\n\n    /*\n        pop due eventItems from queue\n    */\n    pop(now) {\n        let eventItem, res = [];\n        let len = this.queue.length;\n        while (this.queue.length > 0 && this.queue[0].tsEndpoint[0] <= now) {\n            res.push(this.queue.shift());\n        }\n        return res;\n    };\n\n    /*\n        return timestamp of next eventItem\n    */\n    next() {\n        return (this.queue.length > 0) ? this.queue[0].tsEndpoint[0]: undefined;\n    }\n\n\n    /***************************************************************\n        ADVANCE TIMEINTERVAL/POSINTERVAL\n    ***************************************************************/\n\n\n    /*\n        advance timeInterval and posInterval if needed\n    */\n    advance(now) {\n        let start, delta = this.options.lookahead;\n        let advance = false;\n        if (this.timeInterval == undefined) {\n            start = now;\n            advance = true;\n        } else if (endpoint.leftof(this.timeInterval.endpointHigh, now)) {\n            start = this.timeInterval.high;\n            advance = true\n        }\n        if (advance) {\n            // advance intervals\n            this.timeInterval = new Interval(start, start + delta, true, false);\n            this.posInterval = pft(this.timeInterval, this.vector);\n            // clear task queue\n            this.queue = [];\n        }\n        return advance;\n    }\n\n\n    /***************************************************************\n        LOAD\n    ***************************************************************/\n\n    /*\n        load events\n    */\n\n    load(endpoints, minimum_tsEndpoint) {\n        let endpointEvents = motionutils.endpointEvents(this.timeInterval,\n                                                        this.posInterval,\n                                                        this.vector,\n                                                        endpoints);\n\n        /*\n            ISSUE 1\n\n            Range violation might occur within timeInterval.\n            All endpointEvents with .tsEndpoint later or equal to range\n            violation will be cancelled.\n        */\n        let range_ts = motionutils.rangeIntersect(this.vector, this.to.range)[0];\n\n        /*\n            ISSUE 2\n\n            If load is used in response to dynamically added cues, the\n            invocation of load might occor at any time during the timeInterval,\n            as opposed to immediately after the start of timeInterval.\n            This again implies that some of the endPointEvents we have found\n            from the entire timeInterval might already be historic at time of\n            invocation.\n\n            Cancel endpointEvents with .tsEndpoint < minimum_ts.\n\n            For regular loads this will have no effect since we\n            do not specify a minimum_ts, but instead let it assume the\n            default value of timeInterval.low.\n        */\n        if (minimum_tsEndpoint == undefined) {\n            minimum_tsEndpoint = this.timeInterval.endpointLow;\n        }\n\n        /*\n            ISSUE 3\n\n            With acceleration the motion might change direction at\n            some point, which might also be a cue endpoint. In this\n            case, motion touches the cue endpoint but does not actually\n            cross over it.\n\n            For simplicity we say that this should not change the\n            active state of that cue. The cue is either not activated\n            or not inactivated by this occurrence. We might therefor\n            simply drop such endpointEvents.\n\n            To detect this, note that velocity will be exactly 0\n            evaluated at the cue endpoint, but acceleration will be nonzero.\n\n            Importantly, there is one exception. Dropping such events\n            should only happen when 0 velocity is reached during motion,\n            not at the start of a motion. For instance, in the case of\n            starting with acceleration but no velocity, from a cue\n            endpoint, this event should not be dropped.\n            This is avoided by requiring that the tsEndpoint is not\n            equal to timeInterval.endpointLow\n\n        */\n\n        return endpointEvents.filter(function(item) {\n            // ISSUE 1\n            if (range_ts <= item.tsEndpoint[0]) {\n                // console.log(\"issue1\");\n                return false;\n            }\n\n            // ISSUE 2\n            if (endpoint.leftof(item.tsEndpoint, minimum_tsEndpoint)) {\n                // console.log(\"issue2\");\n                return false;\n            }\n            // ISSUE 3\n            // checks every event. alternative approach would be\n            // to calculate the ts of this event once, and compare\n            // the result to the ts of all event\n            if (this.vector.acceleration != 0.0) {\n                let ts = item.tsEndpoint[0];\n                if (ts > this.timeInterval.endpointLow[0]) {\n                    let v = motionutils.calculateVector(this.vector, ts);\n                    if (v.position == item.endpoint[0] && v.velocity == 0) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }, this);\n    }\n\n\n    /***************************************************************\n        RUN\n    ***************************************************************/\n\n    /*\n        run schedule\n    */\n    run(now) {\n        // process - due events\n        let dueEvents = this.pop(now);\n        // advance schedule and load events if needed\n        if (this.advance(now)) {\n            // fetch cue endpoints for posInterval\n            let endpointItems = this.dataset.lookup_endpoints(this.posInterval);\n            // load events and push on queue\n            this.push(this.load(endpointItems));\n            // process - possibly new due events\n            dueEvents.push(...this.pop(now));\n        }\n        if (dueEvents.length > 0) {\n            this._notify_callbacks(now, dueEvents, this);\n        }\n        // timeout - until next due event\n        let ts = this.next() || this.timeInterval.high;\n        this.timeout.setTimeout(Math.min(ts, this.timeInterval.high));\n    }\n}\n\nexport default Schedule;\n\n","/*\n    Copyright 2020\n    Author : Ingar Arntzen\n\n    This file is part of the Timingsrc module.\n\n    Timingsrc is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    Timingsrc is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport {map_intersect, map_difference} from '../util/utils.js';\nimport Interval from '../util/interval.js';\nimport CueCollection from '../dataset/cuecollection.js';\nimport Dataset from '../dataset/dataset.js';\n\n\nfunction isNoop(delta) {\n    return (delta.interval == Dataset.Delta.NOOP && delta.data == Dataset.Delta.NOOP);\n}\n\n\n/*******************************************************************\n ACTIVE MAP\n*******************************************************************/\n/*\n\n    This table describes cue changes to/from active state\n    based on\n\n    - to_role - the role of the timing object\n\n      in the case of the double sequencer a timing object\n      may be *LEFT* (L), *RIGHT* (R) or, in the corner case that\n      the two timing objects are at the same position,\n      *SINGULAR* (S)\n\n      in the case of the single sequencer, the role is\n      always *SINGULAR* (S)\n\n\n    - to_direction - the direction of the movement of the\n      timing object, either *RIGHT* (R) or *LEFT* (L)\n\n      This map is only used when timing object is in a\n      moving state, so *PAUSED* (P) is not needed.\n\n    - endpoint_type - the type of endpoint which is\n      passed by the timing object during motion, either\n      *LEFT* (R) endpoint or *RIGHT* (R) endpoint, or\n      *SINGULAR* (S) endpoint.\n\n    - cue_change\n      *ENTER* : cue changes from not active to active\n      *EXIT*: cue changes from active to not active\n      *STAY*: cue stays active\n      *ENTER-EXIT*: cue changes from not active to active,\n                    and immediately back agoind to not active\n                    This only occurs when a *SINGULAR*\n                    timing object passed a *SINGULAR* cue.\n\n\n    Table columns are:\n\n    | to_role | to_direction | endpoint_type | cue change |\n\n    left, right, left -> stay\n    left, right, right -> exit\n    left, right, singular -> exit\n\n    left, left, left -> stay\n    left, left, right -> enter\n    left, left, singular -> enter\n\n    right, right, left -> enter\n    right, right, right -> stay\n    right, right, singular -> enter\n\n    right, left, left -> exit\n    right, left, right -> stay\n    right, left, singular -> exit\n\n    // cornercase - timing objects are the same\n\n    singular, right, left -> enter\n    singular, right, right -> exit\n    singular, right, singular -> enter, exit\n\n    singular, left, left -> exit\n    singular, left, right -> enter\n    singular, left, singular -> enter, exit\n\n*/\n\nconst Active = Object.freeze({\n    ENTER: 1,\n    STAY: 0,\n    EXIT: -1,\n    ENTER_EXIT: 2\n});\n\nconst ActiveMap = new Map([\n    [\"LRL\", Active.STAY],\n    [\"LRR\", Active.EXIT],\n    [\"LRS\", Active.EXIT],\n    [\"LLL\", Active.STAY],\n    [\"LLR\", Active.ENTER],\n    [\"LLS\", Active.ENTER],\n    [\"RRL\", Active.ENTER],\n    [\"RRR\", Active.STAY],\n    [\"RRS\", Active.ENTER],\n    [\"RLL\", Active.EXIT],\n    [\"RLR\", Active.STAY],\n    [\"RLS\", Active.EXIT],\n    [\"SRL\", Active.ENTER],\n    [\"SRR\", Active.EXIT],\n    [\"SRS\", Active.ENTER_EXIT],\n    [\"SLL\", Active.EXIT],\n    [\"SLR\", Active.ENTER],\n    [\"SLS\", Active.ENTER_EXIT]\n]);\n\n\n\n/*******************************************************************\n DEFAULT EVENT ITEM ORDERING\n*******************************************************************/\n\nfunction cue_cmp_forwards (cue_a, cue_b) {\n    return Interval.cmpLow(cue_a.interval, cue_b.interval);\n}\n\nfunction cue_cmp_backwards (cue_a, cue_b) {\n    return -1 * Interval.cmpHigh(cue_a.interval, cue_b.interval);\n}\n\nfunction item_cmp_forwards (item_a, item_b) {\n    let cue_a = (item_a.new) ? item_a.new : item_a.old;\n    let cue_b = (item_b.new) ? item_b.new : item_b.old;\n    return cue_cmp_forwards(cue_a, cue_b);\n}\n\nfunction item_cmp_backwards (item_a, item_b) {\n    let cue_a = (item_a.new) ? item_a.new : item_a.old;\n    let cue_b = (item_b.new) ? item_b.new : item_b.old;\n    return cue_cmp_backwards(cue_a, cue_b);\n}\n\n/*******************************************************************\n BASE SEQUENCER\n*******************************************************************/\n\n/*\n    This is an abstract base class for sequencers\n    It implements common logic related to Dataset, events and activeCues.\n*/\n\nclass BaseSequencer extends CueCollection {\n\n    static Active = Active;\n    static ActiveMap = ActiveMap;\n\n    constructor (dataset, options) {\n        super(options);\n\n        // Active cues\n        this._map = new Map();\n\n        // Dataset\n        this._ds = dataset;\n        let cb = this._onDatasetCallback.bind(this)\n        this._ds_cb = this._ds.add_callback(cb);\n    }\n\n    /**\n     * CueCollection (ObservableMap) needs access to map \n     */\n    get datasource () {\n        return this._map;\n    }\n\n    /**\n     * Access to dataset of sequencer\n     */\n\n    get dataset () { \n        return this._ds;\n    }\n\n    /***************************************************************\n     EVENTS\n    ***************************************************************/\n\n    /*\n        Get the direction of movement\n        To be implemented by subclass\n    */\n    _movementDirection() {\n        throw new Error(\"not implemented\");\n    }\n\n    // override ObservableMap.sortValues to add special support for\n    // direction sensitive ordering as default ordering\n    sortValues(iter, options={}) {\n        let order = this.sortOrder(options);\n        if (typeof order == \"function\") {\n            // use order specified by options\n            return super.sortValues(iter, options)\n        } else {\n            // if iterable not array - convert into array ahead of sorting\n            let cues = (Array.isArray(iter)) ? iter : [...iter];\n            // default order is direction sensitive\n            let direction = this._movementDirection();\n            if (direction >= 0) {\n                cues.sort(cue_cmp_forwards);\n            } else {\n                cues.sort(cue_cmp_backwards);\n            }\n            return cues\n        } \n    }\n\n\n    // override ObservableMap.sortItems to add special support for\n    // direction sensitive ordering as default ordering\n    sortItems(items, direction) {\n        let order = this.sortOrder(); \n        if (typeof order == \"function\") {\n            // use order speciied by options\n            return super.sortItems(items)            \n        } \n        if (order == undefined) {\n            // default order is direction sensitive\n            if (direction == undefined) {\n                direction = this._movementDirection();\n            }\n            if (direction >= 0) {\n                items.sort(item_cmp_forwards);\n            } else {\n                items.sort(item_cmp_backwards);\n            }\n        }\n    }\n\n    /***************************************************************\n     MAP METHODS\n    ***************************************************************/\n\n    set (key, value) {\n        throw new Error(\"not implemented\");\n    }\n\n    delete (key) {\n        throw new Error(\"not implemented\");\n    }\n\n    clear (key) {\n        throw new Error(\"not implemented\");\n    }\n\n    /***************************************************************\n     DATASET\n    ***************************************************************/\n\n\n\n    _onDatasetCallback(eventMap, relevanceInterval) {\n        throw new Error(\"not implemented\");\n    }\n\n    /*\n        make exit, change and enter events\n        - based on eventMap\n    */\n    _items_from_dataset_events(eventMap, interval) {\n        const enterEvents = [];\n        const changeEvents = [];\n        const exitEvents = [];\n        const first = this._map.size == 0;\n        let is_active, should_be_active, _item;\n        for (let item of eventMap.values()) {\n            if (isNoop(item.delta)) {\n                continue;\n            }\n            // exit, change, enter events\n            is_active = (first) ? false : this._map.has(item.key);\n            should_be_active = false;\n            if (item.new != undefined) {\n                if (item.new.interval.match(interval)) {\n                    should_be_active = true;\n                }\n            }\n            if (is_active && !should_be_active) {\n                // exit\n                _item = {key:item.key, new:undefined, old:item.old};\n                exitEvents.push(_item);\n            } else if (!is_active && should_be_active) {\n                // enter\n                _item = {key:item.key, new:item.new, old:undefined};\n                enterEvents.push(_item);\n            } else if (is_active && should_be_active) {\n                // change\n                _item = {key:item.key, new:item.new, old:item.old};\n                changeEvents.push(_item);\n            }\n        };\n        return [exitEvents, changeEvents, enterEvents];\n    }\n\n    /*\n        make exit, change and enter events\n        - based on dataset.lookup\n    */\n    _items_from_dataset_lookup(eventMap, interval) {\n\n        /*\n            Active cues\n\n            find new set of active cues by querying the dataset\n        */\n        const _activeCues = new Map(this._ds.lookup(interval).map(function(cue) {\n            return [cue.key, cue];\n        }));\n\n        let changeEvents = [];\n        let exitEvents = [];\n        let first = (this._map.size == 0);\n        if (!first){\n\n            /*\n                Change Events\n\n                change cues - cues which are modified, yet remain active cues\n            */\n            let remainCues = map_intersect(this._map, _activeCues);\n            if (remainCues.size > 0) {\n                /*\n                    Two approaches\n\n                    1) large eventMap\n                    eventMap larger than remainCues\n                    - iterate remainCues\n                    - keep those that are found in eventMap\n\n                    2) large remainCues\n                    remainCues larger than eventMap\n                    - iterate eventMap\n                    - keep those that are found in remainCues\n\n                    measurement shows that 2) is better\n                */\n                let cue, _item;\n                for (let item of eventMap.values()) {\n                    cue = remainCues.get(item.key);\n                    if (cue != undefined && !isNoop(item.delta)) {\n                        _item = {key:item.key, new:item.new, old:item.old};\n                        changeEvents.push(_item);\n                    }\n                }\n            }\n\n            /*\n                Exit Events\n                exit cues were in old active cues - but not in new\n            */\n            let exitCues = map_difference(this._map, _activeCues);\n            exitEvents = [...exitCues.values()]\n                .map(cue => {\n                    return {key:cue.key, new:undefined, old:cue};\n                });\n        }\n\n        /*\n            Enter Events\n            enter cues were not in old active cues - but are in new\n        */\n        let enterCues;\n        if (first) {\n            enterCues = _activeCues\n        } else {\n            enterCues = map_difference(_activeCues, this._map);\n        }\n        let enterEvents = [...enterCues.values()]\n            .map(cue => {\n                return {key:cue.key, new:cue, old:undefined};\n            });\n\n        return [exitEvents, changeEvents, enterEvents];\n    }\n\n    /***************************************************************\n     BACKWARD COMPATIBILTY\n\n     Sequencers forward dataset operation to datase\n    ***************************************************************/\n\n    get builder() {\n        return this.dataset.builder;\n    }\n\n    addCue(key, interval, data) {\n        return this.dataset.addCue(key, interval, data);\n    }\n\n    removeCue(key) {\n        return this.dataset.removeCue(key);\n    }\n\n    update(cues, options) {\n        return this.dataset.update(cues, options);\n    }\n\n    clear() {\n        return this.dataset.clear();\n    }\n\n}\n\nexport default BaseSequencer;\n","/*\n    Copyright 2020\n    Author : Ingar Arntzen\n\n    This file is part of the Timingsrc module.\n\n    Timingsrc is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    Timingsrc is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport {array_concat, map_difference} from '../util/utils.js';\nimport Interval from '../util/interval.js';\nimport * as motionutils from '../util/motionutils.js';\nimport Schedule from './schedule.js';\nimport BaseSequencer from './basesequencer.js';\n\nconst PosDelta = motionutils.MotionDelta.PosDelta;\nconst MoveDelta = motionutils.MotionDelta.MoveDelta;\nconst Active = BaseSequencer.Active;\nconst ActiveMap = BaseSequencer.ActiveMap;\n\nconst EVENTMAP_THRESHOLD = 5000;\nconst ACTIVECUES_THRESHOLD = 5000;\n\n\nclass PointModeSequencer extends BaseSequencer {\n\n    constructor (dataset, to, options) {\n\n        super(dataset, options);\n\n        // Timing Object\n        this._to = to;\n        this._sub = this._to.on(\"timingsrc\", this._onTimingCallback.bind(this));\n\n        // Schedule\n        this._sched = new Schedule(this._ds, to);\n        let cb = this._onScheduleCallback.bind(this);\n        this._sched_cb = this._sched.add_callback(cb)\n    }\n\n\n    /*\n        Implement movement direction from single timing object\n    */\n    _movementDirection() {\n        const now = this._to.clock.now();\n        return motionutils.calculateDirection(this._to.vector, now);\n    }\n\n\n    /***************************************************************\n     DATASET CALLBACK\n    ***************************************************************/\n\n    /*\n        Handling Dataset Update Callbacks\n    */\n\n    _onDatasetCallback(eventMap, relevanceInterval) {\n        /*\n            process dataset events which are relevant to the set\n            of activeCues, or to the immediate future (schedule)\n\n            enterCues - inactive -> active\n            changeCues - active -> active, but changed\n            exitCues - active -> inactive\n\n            Two approaches\n            - 1) EVENTS: filter list of events - compare to current active cues\n            - 2) LOOKUP: regenerate new activeCues by looking up set of\n                 active cues from dataset, compare it to current active cues\n\n\n            EventMap.size < about 1K-10K (5K)\n            - EVENTS better or equal\n            EventMap.size > about 5K\n            - LOOKUP better\n            - exception\n                - If activeCues.size > 1K-10K (5K) - EVENTS BETTER\n\n            If new cues are predominantly active cues, EVENTS are\n            always better - and more so for larger sets of events.\n            However, there is no information about this\n            before making the choice, and also this is a somewhat\n            unlikely scenario.\n\n            So, the simple policy above works for typical workloads,\n            where the majority of added cues are inactive.\n        */\n\n        if (!this._to.isReady()) {\n            return;\n        }\n\n        if (relevanceInterval == undefined) {\n            return;\n        }\n\n        const now = this._to.clock.now();\n        const now_vector = motionutils.calculateVector(this._to.vector, now);\n\n        // activeInterval\n        const activeInterval = new Interval(now_vector.position);\n\n        if (!activeInterval.match(relevanceInterval, Interval.Match.OUTSIDE)) {\n            // relevanceInterval is NOT outside activeInterval\n            // some events relevant for activeIntervale\n\n            // choose approach to get events\n            let get_items = this._items_from_dataset_events.bind(this);\n            if (EVENTMAP_THRESHOLD < eventMap.size) {\n                if (this._map.size < ACTIVECUES_THRESHOLD) {\n                    get_items = this._items_from_dataset_lookup.bind(this);\n                }\n            }\n\n            // get items\n            const [exit, change, enter] = get_items(eventMap, activeInterval);\n\n            // update activeCues\n            exit.forEach(item => {\n                this._map.delete(item.key);\n            });\n            enter.forEach(item => {\n                this._map.set(item.key, item.new);\n            });\n\n            // notifications\n            const items = array_concat([exit, change, enter], {copy:true, order:true});\n\n            // sort event items according to general movement direction\n            let direction = motionutils.calculateDirection(now_vector);\n            BaseSequencer.sort_items(items, direction);\n\n            // event notification\n            this._notifyEvents(items);\n        }\n\n        /*\n            clear schedule\n\n            This is only necessary if a cue interval is changed,\n            and the change is relevant within the posInterval of\n            of the schedule. RelevanceInterval to figure this out.\n        */\n        if (this._sched.posInterval) {\n            if (!this._sched.posInterval.match(relevanceInterval, Interval.Match.OUTSIDE)) {\n                // relevanceInterval is NOT outside schedule posInterval\n                // refresh schedule\n                this._sched.setVector(now_vector);\n            }\n        }\n    }\n\n\n    /***************************************************************\n     TIMING OBJECT CALLBACK\n    ***************************************************************/\n\n    _onTimingCallback (eArg) {\n        /*\n            If update is the initial vector from the timing object,\n            we set current time as the official time for the update.\n            Else, the new vector is \"live\" and we use the timestamp\n            when it was created as the official time for the update.\n            This is represented by the new_vector.\n        */\n        let new_vector;\n\n        if (eArg.live) {\n            new_vector = this._to.vector;\n        } else {\n            // make a live vector from to vector\n            new_vector = motionutils.calculateVector(this._to.vector, this._to.clock.now());\n        }\n\n        /*\n            The nature of the vector change\n        */\n        let delta = new motionutils.MotionDelta(this._to.old_vector, new_vector);\n\n        /*\n            Reevaluate active state.\n            This is required after any discontinuity of the position (jump),\n            or if the motion stopped without jumping (pause or halt at range\n            restriction)\n        */\n        const items = [];\n        if (delta.posDelta == PosDelta.CHANGE || delta.moveDelta == MoveDelta.STOP) {\n            // make position interval\n            let low = new_vector.position;\n            let high = new_vector.position;\n            let itv = new Interval(low, high, true, true);\n            // new active cues\n            let activeCues = new Map(this._ds.lookup(itv).map(cue => {\n                return [cue.key, cue];\n            }));\n            // exit cues - in old activeCues but not in new activeCues\n            let exitCues = map_difference(this._map, activeCues);\n            // enter cues - not in old activeCues but in new activeCues\n            let enterCues = map_difference(activeCues, this._map);\n            // update active cues\n            this._map = activeCues;\n            // make event items\n            for (let cue of exitCues.values()) {\n                items.push({key:cue.key, new:undefined, old:cue});\n            }\n            for (let cue of enterCues.values()) {\n                items.push({key:cue.key, new:cue, old:undefined});\n            }\n\n            // sort event items according to general movement direction\n            let direction = motionutils.calculateDirection(new_vector);\n            this.sortItems(items, direction);\n\n            // event notification\n            this._notifyEvents(items);\n        }\n\n        /*\n            Handle Timing Object Moving\n        */\n        this._sched.setVector(new_vector);\n    };\n\n\n    /***************************************************************\n     SCHEDULE CALLBACK\n    ***************************************************************/\n\n    _onScheduleCallback = function(now, endpointItems, schedule) {\n        if (!this._to.isReady()) {\n            return;\n        }\n\n        const items = [];\n        endpointItems.forEach(function (item) {\n            let cue = item.cue;\n            let has_cue = this._map.has(cue.key);\n            let [value, right, closed, singular] = item.endpoint;\n\n            /*\n                Action Code - see sequenceutils\n            */\n            // to role\n            let to_role = \"S\";\n            // movement direction\n            let to_dir = (item.direction > 0) ? \"R\" : \"L\";\n            // endpoint type\n            let ep_type = (singular) ? \"S\": (right) ? \"R\" : \"L\";\n            // action code, enter, exit, stay, enter-exit\n            let action_code = ActiveMap.get(`${to_role}${to_dir}${ep_type}`);\n\n            if (action_code == Active.ENTER_EXIT) {\n                if (has_cue) {\n                    // exit\n                    items.push({key:cue.key, new:undefined, old:cue});\n                    this._map.delete(cue.key);\n                } else {\n                    // enter\n                    items.push({key:cue.key, new:cue, old:undefined});\n                    // exit\n                    items.push({key:cue.key, new:undefined, old:cue});\n                    // no need to both add and remove from activeCues\n                }\n            } else if (action_code == Active.ENTER) {\n                if (!has_cue) {\n                    // enter\n                    items.push({key:cue.key, new:cue, old:undefined});\n                    this._map.set(cue.key, cue);\n                }\n            } else if (action_code == Active.EXIT) {\n                if (has_cue) {\n                    // exit\n                    items.push({key:cue.key, new:undefined, old:cue});\n                    this._map.delete(cue.key);\n                }\n            }\n        }, this);\n\n        // Event items already sorted\n\n        // event notification\n        this._notifyEvents(items);\n    };\n}\n\nexport default PointModeSequencer;\n\n","/*\n    Copyright 2020\n    Author : Ingar Arntzen\n\n    This file is part of the Timingsrc module.\n\n    Timingsrc is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    Timingsrc is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport {array_concat, map_difference} from '../util/utils.js';\nimport Interval from '../util/interval.js';\nimport * as motionutils from '../util/motionutils.js';\nimport Schedule from './schedule.js';\nimport BaseSequencer from './basesequencer.js';\n\nconst PosDelta = motionutils.MotionDelta.PosDelta;\nconst MoveDelta = motionutils.MotionDelta.MoveDelta;\nconst Active = BaseSequencer.Active;\nconst ActiveMap = BaseSequencer.ActiveMap;\n\nconst EVENTMAP_THRESHOLD = 5000;\nconst ACTIVECUES_THRESHOLD = 5000;\n\n/*\n    calculate general movement direction for double sequencer\n    define movement direction as the aggregate movement direction\n    for both timing objects\n*/\nfunction movement_direction (now_vector_A, now_vector_B) {\n    let direction_A = motionutils.calculateDirection(now_vector_A);\n    let direction_B = motionutils.calculateDirection(now_vector_B);\n    let direction = direction_A + direction_B;\n    return (direction > 0) ? 1 : (direction < 0) ? -1 : 0;\n}\n\n\nclass IntervalModeSequencer extends BaseSequencer {\n\n    constructor (dataset, toA, toB, options) {\n\n        super(dataset, options);\n\n        // Timing objects\n        this._toA = toA;\n        this._toA_ready = false;\n        this._toB = toB;\n        this._toB_ready = false;\n        let to_cb = this._onTimingCallback.bind(this);\n        this._subA = this._toA.on(\"timingsrc\", to_cb);\n        this._subB = this._toB.on(\"timingsrc\", to_cb);\n\n        // Schedules\n        let sched_cb = this._onScheduleCallback.bind(this);\n        this._schedA = new Schedule(this._ds, toA);\n        this._schedA_cb = this._schedA.add_callback(sched_cb);\n        this._schedB = new Schedule(this._ds, toB);\n        this._schedB_cb = this._schedB.add_callback(sched_cb);\n    }\n\n\n    _isReady() {\n        return (this._toA_ready && this._toB_ready);\n    }\n\n\n    /*\n        Implement movement direction from two timing objects\n    */\n\n    _movementDirection() {\n        const now = this._toA.clock.now();\n        const now_vector_A = motionutils.calculateVector(this._toA.vector, now);\n        const now_vector_B = motionutils.calculateVector(this._toB.vector, now);\n        return movement_direction(now_vector_A, now_vector_B);\n    }\n\n    /***************************************************************\n     DATASET CALLBACK\n    ***************************************************************/\n\n    /*\n        Handling Dataset Update Callbacks\n    */\n    _onDatasetCallback(eventMap, relevanceInterval) {\n        if (!this._isReady()) {\n            return;\n        }\n\n        if (relevanceInterval == undefined) {\n            return;\n        }\n\n        // assuming both timing objects have the same clock\n        const now = this._toA.clock.now();\n        const now_vector_A = motionutils.calculateVector(this._toA.vector, now);\n        const now_vector_B = motionutils.calculateVector(this._toB.vector, now);\n\n        // active interval\n        let [pos_A, pos_B] = [now_vector_A.position, now_vector_B.position];\n        let [low, high] = (pos_A <= pos_B) ? [pos_A, pos_B] : [pos_B, pos_A];\n        const activeInterval = new Interval(low, high, true, true);\n\n        if (!activeInterval.match(relevanceInterval, Interval.Match.OUTSIDE)) {\n            // relevanceInterval is NOT outside activeInterval\n            // some events relevant for activeIntervale\n\n            // choose approach to get events\n            let get_items = this._items_from_dataset_events.bind(this);\n            if (EVENTMAP_THRESHOLD < eventMap.size) {\n                if (this._map.size < ACTIVECUES_THRESHOLD) {\n                    get_items = this._items_from_dataset_lookup.bind(this);\n                }\n            }\n\n            // get items\n            const [exit, change, enter] = get_items(eventMap, activeInterval);\n\n            // update activeCues\n            exit.forEach(item => {\n                this._map.delete(item.key);\n            });\n            enter.forEach(item => {\n                this._map.set(item.key, item.new);\n            });\n\n            // notifications\n            const items = array_concat([exit, change, enter], {copy:true, order:true});\n\n            // sort event items according to general movement direction\n            let direction = movement_direction(now_vector_A, now_vector_B);\n            this.sortItems(items, direction);\n\n            // event notification\n            this._notifyEvents(items, direction);\n        }\n\n\n        /*\n            clear schedules\n\n            This is only necessary if a cue interval is changed,\n            and the change is relevant within the posInterval of\n            one of the schedules. RelevanceInterval to figure this out.\n        */\n\n        if (this._schedA.posInterval) {\n            if (!this._schedA.posInterval.match(relevanceInterval, Interval.Match.OUTSIDE)) {\n                // relevanceInterval is NOT outside schedule posInterval\n                // refresh schedule\n                this._schedA.setVector(now_vector_A);\n            }\n        }\n\n        if (this._schedB.posInterval) {\n            if (!this._schedB.posInterval.match(relevanceInterval, Interval.Match.OUTSIDE)) {\n                // relevanceInterval is NOT outside schedule posInterval\n                // refresh schedule\n                this._schedB.setVector(now_vector_B);\n            }\n        }\n    }\n\n\n    /***************************************************************\n     TIMING OBJECT CALLBACK\n    ***************************************************************/\n\n    /*\n        Handling Change Events from Timing Objects\n    */\n    _onTimingCallback (eArg, eInfo) {\n\n        /*\n            make sure both timingobjects are ready\n        */\n        let init = false;\n        if (!this._isReady()) {\n            if (eInfo.src == this._toA) {\n                this._toA_ready = true;\n            } else {\n                this._toB_ready = true;\n            }\n            if (this._isReady()) {\n                init = true;\n            } else {\n                return;\n            }\n        }\n\n        /*\n            figure out which timing object was firing\n        */\n        const to = eInfo.src;\n        const other_to = (to == this._toA) ? this._toB : this._toA;\n\n        /*\n            If update is the initial vector from the timing object,\n            we set current time as the official time for the update.\n            Else, the new vector is \"live\" and we use the timestamp\n            when it was created as the official time for the update.\n            This is represented by the new_vector.\n        */\n        let new_vector;\n        if (eArg.live) {\n            new_vector = to.vector;\n        } else {\n            new_vector = motionutils.calculateVector(to.vector, to.clock.now());\n        }\n\n        /*\n            The nature of the vector change\n        */\n        const delta = new motionutils.MotionDelta(to.old_vector, new_vector);\n\n        /*\n            Sample the state of the other timing object at same time.\n        */\n        let ts = new_vector.timestamp;\n        let other_new_vector = motionutils.calculateVector(other_to.vector, ts);\n\n        /*\n            Reevaluate active state.\n            This is required after any discontinuity of the position (jump),\n            or if the motion stopped without jumping (pause or halt at range\n            restriction)\n        */\n        const items = [];\n        if (delta.posDelta == PosDelta.CHANGE || delta.MoveDelta == MoveDelta.STOP) {\n\n            // make position interval\n            let low = Math.min(new_vector.position, other_new_vector.position);\n            let high = Math.max(new_vector.position, other_new_vector.position);\n            let itv = new Interval(low, high, true, true);\n\n            // new active cues\n            let activeCues = new Map(this._ds.lookup(itv).map(cue => {\n                return [cue.key, cue];\n            }));\n            // exit cues - in old activeCues but not in new activeCues\n            let exitCues = map_difference(this._map, activeCues);\n            // enter cues - not in old activeCues but in new activeCues\n            let enterCues = map_difference(activeCues, this._map);\n            // update active cues\n            this._map = activeCues;\n            // make event items\n            for (let cue of exitCues.values()) {\n                items.push({key:cue.key, new:undefined, old:cue});\n            }\n            for (let cue of enterCues.values()) {\n                items.push({key:cue.key, new:cue, old:undefined});\n            }\n\n            // sort event items according to general movement direction\n            let direction = movement_direction(new_vector, other_new_vector);\n            this.sortItems(items, direction);\n\n            // event notification\n            this._notifyEvents(items);\n        }\n\n        /*\n            Handle Timing Object Moving\n            - on init both shedules must be updated\n        */\n        if (to == this._toA) {\n            this._schedA.setVector(new_vector);\n        } else if (to == this._toB) {\n            this._schedB.setVector(new_vector);\n        }\n        if (init) {\n            if (other_to == this._toA) {\n                this._schedA.setVector(other_new_vector);\n            } else if (other_to == this._toB) {\n                this._schedB.setVector(other_new_vector);\n            }\n        }\n    };\n\n\n    /***************************************************************\n     SCHEDULE CALLBACK\n    ***************************************************************/\n\n    /*\n        Handling due Events from Schedules\n    */\n    _onScheduleCallback = function(now, endpointItems, schedule) {\n        if (!this._isReady()) {\n            return;\n        }\n\n        /*\n            figure out which timing object was firing\n        */\n        const to = schedule.to;\n        const other_to = (to == this._toA) ? this._toB : this._toA;\n\n        const items = [];\n        endpointItems.forEach(function (item) {\n\n            /*\n                figure out if to (event source) is lower than the other to\n                at time of event\n            */\n            // endpoint\n            let [pos, right, closed, singular] = item.endpoint;\n            // position of other to at time of event\n            let ts = item.tsEndpoint[0];\n            let other_vector = motionutils.calculateVector(other_to.vector, ts);\n            let pos_other = other_vector.position;\n\n            /*\n                Action Code - see sequenceutils\n            */\n            // to role\n            let to_role = (pos < pos_other) ? \"L\" : (pos == pos_other) ? \"S\" : \"R\";\n            // movement direction\n            let to_dir = (item.direction > 0) ? \"R\" : \"L\";\n            // endpoint type\n            let ep_type = (singular) ? \"S\": (right) ? \"R\" : \"L\";\n            // action code, enter, exit, stay, enter-exit\n            let action_code = ActiveMap.get(`${to_role}${to_dir}${ep_type}`);\n\n            /*\n                state of cue\n            */\n            let cue = item.cue;\n            let has_cue = this._map.has(cue.key);\n\n            // filter action code\n            if (action_code == Active.ENTER_EXIT) {\n                /*\n                    both timing objects evaluated to same position\n                    either\n                    1) to is moving and other_to is paused at this point,\n                       implying that the cue STAYS active\n                    or,\n                    2) both are moving. if both are moving in the same\n                    direction - EXIT\n                    opposite direction - ENTER\n                */\n                let other_moving = motionutils.isMoving(other_vector);\n                if (!other_moving) {\n                    // other not moving\n                    action_code = Active.ENTER;\n                } else {\n                    // both moving\n                    let direction = motionutils.calculateDirection(other_vector);                        // movement direction\n                    action_code = (direction != item.direction) ? Active.ENTER : Active.EXIT;\n                }\n            }\n            if (action_code == Active.STAY) {\n                action_code = Active.ENTER;\n            }\n            if (action_code == Active.ENTER && has_cue) {\n                return;\n            }\n            if (action_code == Active.EXIT && !has_cue) {\n                return;\n            }\n\n            // enter or exit\n            if (action_code == Active.ENTER) {\n                // enter\n                items.push({key:cue.key, new:cue, old:undefined});\n                this._map.set(cue.key, cue);\n            } else if (action_code == Active.EXIT) {\n                // exit\n                items.push({key:cue.key, new:undefined, old:cue});\n                this._map.delete(cue.key);\n            }\n        }, this);\n\n        // Event items already sorted\n\n        // event notification\n        this._notifyEvents(items);\n    }\n}\n\nexport default IntervalModeSequencer;\n\n","/*\n    Copyright 2020\n    Author : Ingar Arntzen\n\n    This file is part of the Timingsrc module.\n\n    Timingsrc is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    Timingsrc is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport {random_string} from '../util/utils.js';\n\nclass DatasetViewer {\n\n    constructor(ds, elem) {\n        this.ds = ds;\n        this.elem = elem;\n        this.nonce = random_string(4);\n        this.ds.on(\"change\", this.onchange.bind(this));\n        this.ds.on(\"remove\", this.onremove.bind(this));\n    }\n\n    cue2string(cue) {\n        let itv = (cue.interval) ? cue.interval.toString() : \"undefined\";\n        let data = JSON.stringify(cue.data); \n        return `${cue.key}, ${itv}, ${data}`;\n    }\n\n    onchange(eItem) {\n        let _id = `${this.nonce}-${eItem.key}`;\n        let node = this.elem.querySelector(`#${_id}`);\n        if (node) {\n            // update existing node\n            node.innerHTML = this.cue2string(eItem.new);\n        } else {\n            // create new node\n            let node = document.createElement(\"div\");\n            node.innerHTML = this.cue2string(eItem.new);\n            node.setAttribute(\"id\", _id);\n            this.elem.appendChild(node);\n        }\n    }\n\n    onremove(eItem) {\n        // remove node\n        let _id = `${this.nonce}-${eItem.key}`;\n        let node = this.elem.querySelector(`#${_id}`);\n        if (node) {\n            node.parentNode.removeChild(node);\n        }\n    }\n}\n\nexport default DatasetViewer;","/*\n\tCopyright 2020\n\tAuthor : Ingar Mhlum Arntzen\n\n\tThis file is part of the Timingsrc module.\n\n\tTimingsrc is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU Lesser General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tTimingsrc is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU Lesser General Public License for more details.\n\n\tYou should have received a copy of the GNU Lesser General Public License\n\talong with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport TimingSampler from \"../timingobject/timingsampler.js\";\n\n/*\n    TODO\n\n    - treat progress change as a speculative\n        change, (with a timeout)\n        implementation - ideally as speculative converter\n        easy solution - just lock\n*/\n\nclass TimingProgress {\n\n    static position2percent(position, range) {\n        let [low, high] = range;\n\n        let offset = position - low;\n        let length = high - low;\n        return 100.0*offset/length;\n    };\n\n    static percent2position(percent, range) {\n        let [low, high] = range;\n        // make sure percent is [0,100]\n        percent = Math.max(0, percent);\n        percent = Math.min(100, percent);\n        let length = high - low;\n        let offset = length*percent/100.0;\n        return low + offset;\n    };\n\n    constructor (timingObject, progress_elem, options={}) {\n        this._to = timingObject;\n        this._sampler = options.sampler;\n        this._progress_elem = progress_elem;\n        this._lock = false;\n        this._options = options;\n        this._range = options.range || this._to.range;\n        let [low, high] = this._range;\n        if (low == -Infinity || high == Infinity) {\n            throw new Error(\"illegal range\", this._range);\n        }\n\n        // subscribe to input event from progress elem\n        this._progress_elem.addEventListener(\"input\", function() {\n            // set lock\n            // no updates on progress elem from timing object until lock is released\n            this._lock_value = true;\n        }.bind(this));\n\n        // subscribe to change event from progress elem\n        this._progress_elem.addEventListener(\"change\", function () { \n            // clear lock\n            this._lock_value = false;\n            // update the timing object\n            let percent = parseInt(this._progress_elem.value);               \n            let position = TimingProgress.percent2position(percent, this._range);\n            this._to.update({position: position});\n        }.bind(this));\n        \n        // sampler\n        if (this._sampler) {\n            this._sampler.on(\"change\", this.refresh.bind(this));\n        }\n    }\n\n    refresh() {\n        let position = this._to.pos;\n        // update progress elem if unlocked\n        if (!this._lock_value) {\n            let percent = TimingProgress.position2percent(position, this._range);\n            if (this._options.thumb) {\n                // check if percent is legal\n                if (percent < 0.0 || 100.0 < percent) {\n                    // hide\n                    this._options.thumb.hide();\n                    return;\n                }\n            } else {\n                percent = (percent < 0.0) ? 0.0 : percent;\n                percent = (100.0 < percent) ? 100.0: percent;\n            }\n            this._progress_elem.value = `${percent}`;\n            if (this._options.thumb) {\n                this._options.thumb.show();            \n            }\n        }\n    }\n}\n\nexport default TimingProgress;","\n/*\n    Copyright 2020\n    Author : Ingar Arntzen\n\n    This file is part of the Timingsrc module.\n\n    Timingsrc is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    Timingsrc is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with Timingsrc.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n// utils\nexport * as utils from './util/utils.js';\nexport * as motionutils from './util/motionutils.js';\nexport {default as BinarySearch} from './util/binarysearch.js';\nexport {default as endpoint} from './util/endpoint.js';\nexport {default as eventify} from './util/eventify.js';\nexport {default as Interval} from './util/interval.js';\nexport {default as ObservableMap} from './util/observablemap.js';\nexport {default as Timeout} from './util/timeout.js';\n\n// timing object\nimport {default as TimingObject} from './timingobject/timingobject.js';\nexport {TimingObject};\nexport {default as SkewConverter} from './timingobject/skewconverter.js';\nexport {default as DelayConverter} from './timingobject/delayconverter.js';\nexport {default as ScaleConverter} from './timingobject/scaleconverter.js';\nexport {default as LoopConverter} from './timingobject/loopconverter.js';\nexport {default as RangeConverter} from './timingobject/rangeconverter.js';\nexport {default as TimeshiftConverter} from './timingobject/timeshiftconverter.js';\nexport {default as TimingSampler} from './timingobject/timingsampler.js';\nexport {default as PositionCallback} from './timingobject/positioncallback.js';\n\n// timed data\nimport {default as Dataset} from './dataset/dataset.js';\nexport {Dataset};\nexport {default as Subset} from './dataset/subset.js';\nimport {default as PointModeSequencer} from './sequencing/pointsequencer.js';\nimport {default as IntervalModeSequencer} from './sequencing/intervalsequencer.js';\n\n// create single sequencer factory function\nexport function Sequencer() {\n    // find datasets in arguments\n    let ds_list = [...arguments].filter((e) => (e instanceof Dataset));\n    let ds = (ds_list.length > 0) ? ds_list[0] : new Dataset();\n    // find timing objects in arguments\n    let to_list = [...arguments].filter((e) => (e instanceof TimingObject));\n    // find options (plain objects) in arguments\n    let obj_list = [...arguments].filter((e) => (Object.getPrototypeOf(e) === Object.prototype));\n    let options = (obj_list.length > 0) ? obj_list[0] : {};\n    if (to_list.length == 0) {\n        throw new Error(\"no timingobject in arguments\");\n    } else if (to_list.length == 1) {\n        return new PointModeSequencer(ds, to_list[0], options);\n    } else {\n        return new IntervalModeSequencer(ds, to_list[0], to_list[1], options);\n    }\n};\n\n// Add clone functions for backwards compatibility\nPointModeSequencer.prototype.clone = function () {\n    let args = [this.ds];\n    args.push.apply(args, [...arguments]);\n    return Sequencer(...args);\n};\n\n// Add clone functions for backwards compatibility\nIntervalModeSequencer.prototype.clone = function () {\n    let args = [this.ds];\n    args.push.apply(args, [...arguments]);\n    return Sequencer(...args);\n};\n\n// ui\nexport {default as DatasetViewer} from './ui/datasetviewer.js';\nexport {default as TimingProgress} from './ui/timingprogress.js';\n\nexport const version = \"v3.0\";\n"],"names":["random_string","length","text","possible","i","charAt","Math","floor","random","all","pred","as","a","isIn","has","map_difference","b","size","Map","filter","key","value","map_intersect","isIterable","obj","Symbol","iterator","array_concat","arrays","options","copy","order","total_len","reduce","acc","cur","sort","end","len","first","shift","start","arr","object_equals","propName","aProps","Object","getOwnPropertyNames","bProps","docready","Promise","resolve","document","readyState","onReady","removeEventListener","window","addEventListener","bs","array_of_maps","Array","isArray","Error","map","o","every","e","m","val","entries","set","n","d","r","isNumber","N","parseFloat","isNaN","create","right","closed","singular","Infinity","get_mode","undefined","get_order","e1","e2","cmp","order1","order2","diff","toString","mode","equals","rightof","leftof","min","max","IntervalError","[object Object]","message","super","this","name","Relation","freeze","OUTSIDE_LEFT","OVERLAP_LEFT","COVERED","EQUALS","COVERS","OVERLAP_RIGHT","OUTSIDE_RIGHT","MATCH_OUTSIDE","MATCH_INSIDE","MATCH_OVERLAP","MATCH_COVERS","MATCH_ALL","Match","OUTSIDE","INSIDE","OVERLAP","ALL","compare","Interval","endpoint","endpointLow","endpointHigh","includes","_make_interval_cmp","low","lowInclude","high","highInclude","fromEndpoints","low_right","low_closed","low_singular","high_right","high_closed","high_singular","intersect","rel","union","intersectAll","intervals","cmpLow","result","prev","pop","next","push","unionAll","finite","isFinite","p","other","mask","relation","Boolean","equalVectors","vector_a","vector_b","pos","position","vel","velocity","acceleration","ts","timestamp","calculateVector","vector","deltaSec","calculateDirection","freshVector","direction","isMoving","RangeState","INIT","OUTSIDE_LOW","OUTSIDE_HIGH","correctRangeState","range","v","checkRange","state","rangeIntersect","t0","deltaLeft","calculateMinPositiveRealSolution","deltaRight","hasRealSolution","x","pow","calculateRealSolutions","sqrt","d1","d2","res","calculatePositiveRealSolutions","calculateDelta","deltaBeforeSec","deltaAfterSec","posInterval_from_timeInterval","timeInterval","t1","t0_closed","t1_closed","vector0","p0","v0","a0","p1","t_extrem","covers_endpoint","p_extrem","timeEndpoint_from_posEndpoint","posEndpoint","close","endpointEvents","posInterval","endpointItems","deltas","tsEndpoint","eventItems","forEach","item","delta","MotionDelta","NOOP","CHANGE","NOOP_MOVING","START","STOP","old_vector","new_vector","is_moving","init","PosDelta","MoveDelta","_mc","mct","was_moving","end_vector","start_vector","pct","vel_changed","acc_changed","posDelta","moveDelta","str","BinarySearchError","BinarySearch","array","searchElement","currentIndex","currentElement","minIndex","maxIndex","index","binaryIndexOf","isFound","elements","indexes","indexOf","to_remove","to_insert","indexOfElements","splice","abs","concat","A","Set","approach","arrayLength","batchLength","_update_splice","_update_sort","idx","interval","start_index","end_index","geIndexOf","gtIndexOf","leIndexOf","ltIndexOf","lookupIndexes","slice","removeList","rd_ptr","wr_ptr","rm_ptr","rd_elem","rm_elem","values","Event","publisher","subscriptions","callback","sub","Subscription","init_pending","self","then","eArgs","eventifyInitEventArgs","eArg","trigger","subs","eInfo","ctx","terminated","src","call","err","console","log","terminate","event","unsubscribe","eventifyInstance","object","__eventify_eventMap","__eventify_buffer","eventifyPrototype","_prototype","eventifyGetEvent","get","eventifyDefine","eventifyTrigger","eventifyTriggerAll","eventifyTriggerAlike","triggerItems","ev","buf","buf_len","eventifySubscriptions","on","subscribe","off","EventVariable","_value","prototype","EventBoolean","makePromise","eventObject","conditionFunc","reject","ObservableMap","eventify","datasource","iter","sortOrder","items","item_a","item_b","cue_a","new","old","cue_b","sortItems","has_update_subs","has_remove_subs","has_change_subs","keys","_notifyEvents","delete","clear","Timeout","timingObject","tid","to","target_ts","arg","now","clock","delay","setTimeout","onTimeout","bind","clearTimeout","performance","offset","Date","getTime","local_clock","tsSec","MasterClock","_vector","adjust","nowVector","query","skew","rate","InternalProvider","_clock","_range","_callback","_process_update","rest","_old_vector","ExternalProvider","provider","required","prop","checkTimingProvider","_provider","_ready","_provider_clock","_onVectorChange","_onSkewChange","local_ts","current_skew","skew_delta","isReady","live","update","motionutils.checkRange","motionutils.calculateVector","TimingObject","timingsrc","isTimingProvider","__options","timeout","__old_vector","__vector","__range","__timeout","__handleTimeout","__tid","__timingsrc","__sub","__update_events","__ready","__set_timingsrc","ready","motionutils.MotionDelta","version","isSet","__process","onRangeViolation","__update","ok","tunnel","promise","_arg","onUpdateStart","range_change","vector_change","motionutils.equalVectors","__dispatchEvents","__renewTimeout","onUpdateDone","moving","motionutils.isMoving","setInterval","timeout_vector","__calculateTimeoutVector","now_vector","motionutils.calculateDelta","__handleEvent","__get_timingsrc","__clear_timingsrc","SkewConverter","_skew","DelayConverter","_delay","_buffer","_timeout","__handleDelayed","due","ScaleConverter","factor","_factor","scale","transform","LoopConverter","now_vector_src","_state","new_state","new_range","absolute","special","old_state","is_special_state_change","RangeConverter","__state","onVectorChange","state_changed","TimeshiftConverter","_offset","TimingSampler","_to","_tid","period","frequency","_period","_sub","_onChange","_onSample","float2point","stride","mod","divmod","point2float","q","PositionCallback","_stride","_handleTimeout","_renewTimeout","before","after","rLow","rHigh","match","stride_points","_calculateTimeout","CueCollection","cmpHigh","cues","sortValues","removeCueFromArray","cue","findIndex","_cue","CueBucketIds","getCueBucketId","Delta","INSERT","REPLACE","DELETE","cue_delta","interval_delta","data_delta","eq","a_interval_defined","b_interval_defined","a_data_defined","data","b_data_defined","utils.object_equals","cue_cmp_forwards","iterval","cue_cmp_backwards","sort_cues","cuess","CueArgBuilder","dataset","_cues","_ds","Dataset","_map","_cueBuckets","cueBucketId","CueBucket","_update_callbacks","handler","handle","indexof","batchMap","relevanceInterval","builder","addCue","submit","removeCue","current_cue","has_interval","has_data","check","chaining","utils.isIterable","hasOwnProperty","_update_cue","_call_buckets","relevance","_notify_callbacks","old_cue","new_cue","_item","oldCueBucket","newCueBucket","low_changed","high_changed","remove_needed","add_needed","cue_copy","old_bid","new_bid","del_endpoint","add_endpoint","method","args","cueBucket","utils.array_concat","points","bucketInfo","maxLength","_maxLength","_pointMap","_pointIndex","_created","_dirty","point","add","broader_interval","lookup","_endpoint","cueSet","_mask","_lookup_cues","left_interval","j","removeInSlice","missing","Subset","_key_filter","key_filter","_data_filter","data_filter","_interval","_data_convert","data_convert","_size","_callbacks","_src_ds","cb","_onDatasetCallback","_src_ds_cb","add_callback","itv","_setInterval","_items","_old","_cue_keep","_new","_cue_convert","intersects","_check_interval","lookup_endpoints","eventMap","_items_filter_convert","_inverval","current_cues","new_cues","currentCueMap","newCueMap","exitCueMap","enterCueMap","exitItems","enterItems","pft","motionutils.posInterval_from_timeInterval","queueCmp","Schedule","run","queue","callbacks","lookahead","LOOKAHEAD","advance","endpoints","minimum_tsEndpoint","motionutils.endpointEvents","range_ts","motionutils.rangeIntersect","dueEvents","load","isNoop","Active","ENTER","STAY","EXIT","ENTER_EXIT","ActiveMap","item_cmp_forwards","item_cmp_backwards","BaseSequencer","_ds_cb","_movementDirection","enterEvents","changeEvents","exitEvents","is_active","should_be_active","_activeCues","enterCues","remainCues","PointModeSequencer","_onTimingCallback","_sched","_onScheduleCallback","_sched_cb","motionutils.calculateDirection","activeInterval","get_items","_items_from_dataset_events","_items_from_dataset_lookup","exit","change","enter","sort_items","setVector","activeCues","exitCues","schedule","has_cue","to_dir","ep_type","action_code","movement_direction","now_vector_A","now_vector_B","IntervalModeSequencer","toA","toB","_toA","_toA_ready","_toB","_toB_ready","to_cb","_subA","_subB","sched_cb","_schedA","_schedA_cb","_schedB","_schedB_cb","_isReady","pos_A","pos_B","other_to","other_new_vector","other_vector","pos_other","to_role","DatasetViewer","ds","elem","nonce","onchange","onremove","JSON","stringify","eItem","_id","node","querySelector","innerHTML","cue2string","createElement","setAttribute","appendChild","parentNode","removeChild","TimingProgress","percent","progress_elem","_sampler","sampler","_progress_elem","_lock","_options","_lock_value","parseInt","percent2position","refresh","position2percent","thumb","hide","show","Sequencer","ds_list","arguments","to_list","obj_list","getPrototypeOf","clone","apply"],"mappings":"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"}